diff --git a/README.md b/README.md
index 2a21aef..196a62d 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,101 @@
+ModHE implementation for OpenFHE
+=====================================
+Based on version 1.2.2 (commit 7b8346f4eac27121543e36c17237b919e03ec058)
+
+## Supported Features and Operations
+ * **PKE**
+   * KeyGen
+   * Encrypt
+   * Decrypt
+ * **LeveledSHE**
+   * EvalMultModKeyGen
+   * EvalRankRedKeyGen
+   * EvalAdd
+   * EvalSub
+   * EvalMultAndRelinearize
+   * EvalMultNoRelin
+   * Relinearize
+   * Negate
+   * EvalRankReduce
+ * **KeySwitch**
+   * Hybrid Key Switching
+ * Scaling techniques: FIXEDMANUAL, FIXEDAUTO, FLEXIBLEAUTO, FLEXIBLEAUTOEXT
+
+## Unsupported Features and Operations
+ * Ciphertext-Plaintext operations
+ * Ciphertext-Double operations
+ * Decryption of non relinearized ciphertexts
+ * **LeveledSHE**
+   * EvalMultKeyGen
+   * EvalMult
+   * EvalSquare
+   * EvalRotate
+   * EvalAtIndex
+   * EvalFastRotation
+   * EvalAutomorphism
+ * **KeySwitch**
+   * BV Key Switching
+ * **PRE**
+ * **Multiparty**
+ * **AdvancedSHE**
+ * **FHE**
+ * **SchemeSwitch**
+
+## Interface changes
+Due to interface incompatibilities some small changes between CKKSRNS and CKKSMod are necessary when using the library:
+1. use `EvalMultModKeyGen` instead of `EvalMultKeyGen` for relinearization key generation
+2. use `EvalMultAndRelinearize` instead of `EvalMult` for multiplication.
+
+## Example
+A simple example for how to use the CKKSMod scheme (including the new rank reduction subroutine) can be found in the file `src/pke/examples/simple-real-numbers-mod.cpp`.
+
+Execute using `./bin/examples/pke/simple-real-numbers-mod`.
+
+## Tests:
+The following command executes just the unit tests related to CKKSMod from the file `src/pke/unittest/utckksmod/UnitTestCKKSmod.cpp`:
+
+`./unitest/pke_tests --gtest_filter="*CKKSMod*"`
+
+## Benchmark
+The code used to benchmark the implementation can be found in `benchmark/src/ckksmod.cpp`.
+It does not use the google benchmark library, instead it creates a custom csv file containing all measurements.
+
+`./bin/benchmark/ckksmod`
+
+
+## Implementation
+Simplified overview of the files containing the CKKSMod implementation:
+* Ciphertext element type: `src/core/dcrtmodule.h`
+* Subroutine implementation:
+  * CCKSMod:
+    ```
+    src/pke/include/keyswitch/keyswitch-mod.h
+    src/pke/include/scheme/ckksmod/ckksmod-scheme.h
+    src/pke/include/scheme/ckksmod/ckksmod-pke.h
+    src/pke/include/scheme/ckksmod/ckksmod-leveledshe.h
+    ```
+  * General Classes:
+    ```
+    src/pke/include/schemebase/base-leveledshe.h
+    src/pke/include/schemebase/base-scheme.h
+    src/pke/include/cryptocontext.h
+    ```
+* Parameter generation:
+  ```
+  src/pke/include/scheme/ckksmod/ckksmod-cryptoparamters.h
+  src/pke/include/scheme/ckksmod/ckksmod-parametergeneration.h
+  src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-internal.h
+  src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-params.h
+  src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod.h
+  src/pke/include/schemebase/rlwe-cryptoparameters.h
+  ```
+* Default scheme values: `src/pke/include/scheme/gen-cryptocontext-params-defaults.h`
+* Example: `src/pke/examples/simple-real-numbers-mod.cpp`
+* Benchmark: `benchmark/src/ckksmod.cpp`
+* Testing: `src/pke/unittest/utckksmod/UnitTestCKKSmod.cpp`
+
+Original OpenFHE Readme below:
+
 OpenFHE - Open-Source Fully Homomorphic Encryption Library
 =====================================
 
diff --git a/benchmark/src/ckksmod.cpp b/benchmark/src/ckksmod.cpp
new file mode 100644
index 0000000..43f5847
--- /dev/null
+++ b/benchmark/src/ckksmod.cpp
@@ -0,0 +1,238 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+  Simple examples for ModHE
+ */
+
+#define PROFILE
+
+#include <chrono>
+#include <functional>
+#include <optional>
+
+#include "openfhe.h"
+
+using namespace lbcrypto;
+
+using CT   = Ciphertext<DCRTModule>;
+using CC   = CryptoContext<DCRTModule>;
+using Keys = KeyPair<DCRTModule>;
+
+struct BenchResult {
+    long millis;
+    long iterations;
+
+    friend std::ostream& operator<<(std::ostream& os, const BenchResult& bench) {
+        return os << bench.iterations << "," << bench.millis;
+    }
+};
+
+BenchResult benchmark(CC& cc, Keys& keys, Plaintext ptxt1, CT& c1, CT& c2, std::optional<CT> c3,
+                      std::function<void(CC, Keys, Plaintext, CT, CT, std::optional<CT>)> bench) {
+    uint32_t iterations = 10;
+    while (true) {
+        auto started = std::chrono::high_resolution_clock::now();
+        for (uint32_t i = 0; i < iterations; i++) {
+            bench(cc, keys, ptxt1, c1, c2, c3);
+        }
+        auto done   = std::chrono::high_resolution_clock::now();
+        auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(done - started).count();
+        if (millis >= 100)
+            return {millis, iterations};
+        iterations *= 2;
+    }
+}
+
+int runRankRed() {
+    std::cout << "operation,ringDim,rank,scaleModSize,multDepth,newRank,iterations,ms" << std::endl;
+    uint32_t scaleModSize = 50;
+
+    for (uint32_t moduleRank = 2; moduleRank <= 32; moduleRank *= 2) {
+        for (uint32_t newRank = 1; newRank < moduleRank; newRank++) {
+            uint32_t ringDim   = 1024;
+            uint32_t multDepth = 2;
+            CCParams<CryptoContextCKKSMod> parameters;
+            parameters.SetRingDim(ringDim);
+            parameters.SetSecurityLevel(HEStd_NotSet);
+            parameters.SetMultiplicativeDepth(multDepth);
+            parameters.SetScalingModSize(scaleModSize);
+            parameters.SetBatchSize(8);
+            parameters.SetModuleRank(moduleRank);
+            parameters.SetScalingTechnique(FLEXIBLEAUTOEXT);
+
+            CryptoContext<DCRTModule> cc = GenCryptoContext(parameters);
+
+            cc->Enable(PKE);
+            cc->Enable(LEVELEDSHE);
+            cc->Enable(KEYSWITCH);
+
+            auto keys = cc->KeyGen();
+
+            std::vector<double> x1 = {0.25, 0.5, 0.75, 1.0, 2.0, 3.0, 4.0, 5.0};
+
+            Plaintext ptxt1 = cc->MakeCKKSPackedPlaintext(x1);
+
+            auto c1 = cc->Encrypt(keys.publicKey, ptxt1);
+
+            PrivateKey<DCRTModule> reducedKey;
+
+            auto rankredKey = cc->EvalRankRedKeyGen(keys.secretKey, reducedKey, newRank);
+            auto cRed       = cc->EvalRankReduce(c1, rankredKey);
+
+            std::cout << "RankRedKeyGen," << ringDim << "," << moduleRank << "," << scaleModSize << "," << multDepth
+                      << "," << newRank << ","
+                      << benchmark(cc, keys, ptxt1, c1, c1, std::nullopt,
+                                   [newRank](CC cc, Keys keys, Plaintext pt, CT c1, CT, std::optional<CT>) {
+                                       PrivateKey<DCRTModule> reducedKey;
+                                       cc->EvalRankRedKeyGen(keys.secretKey, reducedKey, newRank);
+                                   })
+                      << std::endl;
+
+            std::cout << "RankRed," << ringDim << "," << moduleRank << "," << scaleModSize << "," << multDepth << ","
+                      << newRank << ","
+                      << benchmark(cc, keys, ptxt1, c1, c1, std::nullopt,
+                                   [rankredKey](CC cc, Keys keys, Plaintext pt, CT c1, CT, std::optional<CT>) {
+                                       cc->EvalRankReduce(c1, rankredKey);
+                                   })
+                      << std::endl;
+        }
+    }
+
+    return 0;
+}
+
+int runBaseOperations() {
+    std::cout << "operation,ringDim,rank,scaleModSize,multDepth,iterations,ms" << std::endl;
+    uint32_t scaleModSize = 50;
+
+    for (uint32_t multDepth = 2; multDepth <= 2; multDepth++) {
+        for (uint32_t ringDim = 1024; ringDim <= 1024 * 128; ringDim *= 2) {
+            for (uint32_t moduleRank = 1; ringDim * moduleRank <= 1024 * 128; moduleRank *= 2) {
+                CCParams<CryptoContextCKKSMod> parameters;
+                parameters.SetRingDim(ringDim);
+                parameters.SetSecurityLevel(HEStd_NotSet);
+                parameters.SetMultiplicativeDepth(multDepth);
+                parameters.SetScalingModSize(scaleModSize);
+                parameters.SetBatchSize(8);
+                parameters.SetModuleRank(moduleRank);
+                parameters.SetScalingTechnique(FLEXIBLEAUTOEXT);
+
+                CryptoContext<DCRTModule> cc = GenCryptoContext(parameters);
+
+                cc->Enable(PKE);
+                cc->Enable(LEVELEDSHE);
+                cc->Enable(KEYSWITCH);
+
+                auto keys = cc->KeyGen();
+
+                std::vector<double> x1 = {0.25, 0.5, 0.75, 1.0, 2.0, 3.0, 4.0, 5.0};
+                std::vector<double> x2 = {5.0, 4.0, 3.0, 2.0, 1.0, 0.75, 0.5, 0.25};
+
+                Plaintext ptxt1 = cc->MakeCKKSPackedPlaintext(x1);
+                Plaintext ptxt2 = cc->MakeCKKSPackedPlaintext(x2);
+
+                auto c1 = cc->Encrypt(keys.publicKey, ptxt1);
+                auto c2 = cc->Encrypt(keys.publicKey, ptxt2);
+
+                std::cout << "KeyGen," << ringDim << "," << moduleRank << "," << scaleModSize << "," << multDepth << ","
+                          << benchmark(
+                                 cc, keys, ptxt1, c1, c2, std::nullopt,
+                                 [](CC cc, Keys keys, Plaintext pt, CT c1, CT, std::optional<CT>) { cc->KeyGen(); })
+                          << std::endl;
+                std::cout << "Decrypt," << ringDim << "," << moduleRank << "," << scaleModSize << "," << multDepth
+                          << ","
+                          << benchmark(cc, keys, ptxt1, c1, c2, std::nullopt,
+                                       [](CC cc, Keys keys, Plaintext pt, CT c1, CT, std::optional<CT>) {
+                                           cc->Decrypt(keys.secretKey, c1, &pt);
+                                       })
+                          << std::endl;
+                std::cout << "Encrypt," << ringDim << "," << moduleRank << "," << scaleModSize << "," << multDepth
+                          << ","
+                          << benchmark(cc, keys, ptxt1, c1, c2, std::nullopt,
+                                       [](CC cc, Keys keys, Plaintext pt, CT c1, CT, std::optional<CT>) {
+                                           cc->Encrypt(keys.publicKey, pt);
+                                       })
+                          << std::endl;
+
+                std::cout << "EvalAdd," << ringDim << "," << moduleRank << "," << scaleModSize << "," << multDepth
+                          << ","
+                          << benchmark(
+                                 cc, keys, ptxt1, c1, c2, std::nullopt,
+                                 [](CC cc, Keys, Plaintext, CT c1, CT c2, std::optional<CT>) { cc->EvalAdd(c1, c2); })
+                          << std::endl;
+
+                std::cout << "EvalSub," << ringDim << "," << moduleRank << "," << scaleModSize << "," << multDepth
+                          << ","
+                          << benchmark(
+                                 cc, keys, ptxt1, c1, c2, std::nullopt,
+                                 [](CC cc, Keys, Plaintext, CT c1, CT c2, std::optional<CT>) { cc->EvalSub(c1, c2); })
+                          << std::endl;
+
+                std::cout << "EvalMultNoRelin," << ringDim << "," << moduleRank << "," << scaleModSize << ","
+                          << multDepth << ","
+
+                          << benchmark(cc, keys, ptxt1, c1, c2, std::nullopt,
+                                       [](CC cc, Keys, Plaintext, CT c1, CT c2, std::optional<CT>) {
+                                           cc->EvalMultNoRelin(c1, c2);
+                                       })
+                          << std::endl;
+
+                if (ringDim * moduleRank <= 1024 * 32) {
+                    cc->EvalMultModKeyGen(keys.secretKey);
+
+                    std::cout << "EvalMultModKeyGen," << ringDim << "," << moduleRank << "," << scaleModSize << ","
+                              << multDepth << ","
+                              << benchmark(cc, keys, ptxt1, c1, c2, std::nullopt,
+                                           [](CC cc, Keys keys, Plaintext pt, CT c1, CT, std::optional<CT>) {
+                                               cc->EvalMultModKeyGen(keys.secretKey);
+                                           })
+                              << std::endl;
+
+                    std::cout << "Relinearize," << ringDim << "," << moduleRank << "," << scaleModSize << ","
+                              << multDepth << ","
+                              << benchmark(
+                                     cc, keys, ptxt1, c1, c2, cc->EvalMultNoRelin(c1, c2),
+                                     [](CC cc, Keys, Plaintext, CT, CT, std::optional<CT> c3) { cc->Relinearize(*c3); })
+                              << std::endl;
+                }
+            }
+        }
+    }
+
+    return 0;
+}
+
+int main() {
+    runBaseOperations();
+    // runRankRed();
+    return 0;
+}
\ No newline at end of file
diff --git a/src/core/include/lattice/hal/default/dcrtmodule.h b/src/core/include/lattice/hal/default/dcrtmodule.h
new file mode 100644
index 0000000..fa018d0
--- /dev/null
+++ b/src/core/include/lattice/hal/default/dcrtmodule.h
@@ -0,0 +1,1090 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+  Represents integer lattice elements with double-CRT
+ */
+
+#ifndef LBCRYPTO_INC_LATTICE_HAL_DEFAULT_DCRTMODULE_H
+#define LBCRYPTO_INC_LATTICE_HAL_DEFAULT_DCRTMODULE_H
+
+#include "lattice/hal/default/ildcrtparams.h"
+#include "lattice/hal/default/poly.h"
+#include "lattice/hal/dcrtpoly-interface.h"
+
+#include "math/math-hal.h"
+#include "math/distrgen.h"
+
+#include "utils/exception.h"
+#include "utils/inttypes.h"
+#include "utils/parallel.h"
+
+#include <functional>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace lbcrypto {
+
+template <typename VecType>
+class DCRTModuleImpl final : public ILElement<DCRTModuleImpl<VecType>, VecType> {
+public:
+    using Vector                  = VecType;
+    using Integer                 = typename VecType::Integer;
+    using Params                  = ILDCRTParams<Integer>;
+    using PolyType                = PolyImpl<NativeVector>;
+    using PolyLargeType           = PolyImpl<VecType>;
+    using DCRTPolyType            = DCRTPolyImpl<VecType>;
+    using DCRTPolyInterfaceType   = DCRTPolyInterface<DCRTPolyImpl<VecType>, VecType, NativeVector, PolyImpl>;
+    using DCRTModuleType          = DCRTModuleImpl<VecType>;
+    using DCRTModuleInterfaceType = ILElement<DCRTModuleImpl<VecType>, VecType>;
+    using Precomputations         = typename DCRTPolyInterfaceType::CRTBasisExtensionPrecomputations;
+    using DggType                 = typename DCRTPolyInterfaceType::DggType;
+    using DugType                 = typename DCRTPolyInterfaceType::DugType;
+    using TugType                 = typename DCRTPolyInterfaceType::TugType;
+    using BugType                 = typename DCRTPolyInterfaceType::BugType;
+
+    DCRTModuleImpl() = default;
+
+    DCRTModuleImpl(const std::shared_ptr<Params>& params, const Format format = Format::EVALUATION,
+                   bool initializeElementToZero = false, uint32_t moduleRows = 1, uint32_t moduleCols = 1) noexcept
+        : m_params{params}, m_format{format}, m_vectors{}, m_moduleRows{moduleRows}, m_moduleCols{moduleCols} {
+        m_vectors.reserve(m_moduleRows * m_moduleCols);
+        for (usint i = 0; i < m_moduleRows * m_moduleCols; i++) {
+            m_vectors.emplace_back(m_params, m_format, initializeElementToZero);
+        }
+    }
+
+    DCRTModuleImpl(const DggType& dgg, const std::shared_ptr<Params>& dcrtParams, Format format,
+                   uint32_t moduleRows = 1, uint32_t moduleCols = 1)
+        : m_params{dcrtParams}, m_format{format}, m_moduleRows{moduleRows}, m_moduleCols{moduleCols} {
+        m_vectors.reserve(m_moduleRows * m_moduleCols);
+        for (usint i = 0; i < m_moduleRows * m_moduleCols; i++) {
+            m_vectors.emplace_back(dgg, m_params, m_format);
+        }
+    }
+
+    DCRTModuleImpl(DugType& dug, const std::shared_ptr<Params>& dcrtParams, Format format, uint32_t moduleRows = 1,
+                   uint32_t moduleCols = 1)
+        : m_params{dcrtParams}, m_format{format}, m_moduleRows{moduleRows}, m_moduleCols{moduleCols} {
+        m_vectors.reserve(m_moduleRows * m_moduleCols);
+        for (usint i = 0; i < m_moduleRows * m_moduleCols; i++) {
+            m_vectors.emplace_back(dug, m_params, m_format);
+        }
+    }
+
+    DCRTModuleImpl(const BugType& bug, const std::shared_ptr<Params>& dcrtParams, Format format,
+                   uint32_t moduleRows = 1, uint32_t moduleCols = 1)
+        : m_params{dcrtParams}, m_format{format}, m_moduleRows{moduleRows}, m_moduleCols{moduleCols} {
+        m_vectors.reserve(m_moduleRows * m_moduleCols);
+        for (usint i = 0; i < m_moduleRows * m_moduleCols; i++) {
+            m_vectors.emplace_back(bug, m_params, m_format);
+        }
+    }
+
+    DCRTModuleImpl(const TugType& tug, const std::shared_ptr<Params>& dcrtParams, Format format, uint32_t h = 0,
+                   uint32_t moduleRows = 1, uint32_t moduleCols = 1)
+        : m_params{dcrtParams}, m_format{format}, m_moduleRows{moduleRows}, m_moduleCols{moduleCols} {
+        m_vectors.reserve(m_moduleRows * m_moduleCols);
+        for (usint i = 0; i < m_moduleRows * m_moduleCols; i++) {
+            m_vectors.emplace_back(tug, m_params, m_format, h);
+        }
+    }
+
+    DCRTModuleImpl(const DCRTPolyType& poly) noexcept
+        : m_params{poly.GetParams()}, m_format{poly.GetFormat()}, m_vectors{}, m_moduleRows{1}, m_moduleCols{1} {
+        m_vectors.resize(1);
+        m_vectors[0] = poly;
+    }
+
+    DCRTModuleImpl(const DCRTModuleType& e) noexcept
+        : m_params{e.m_params},
+          m_format{e.m_format},
+          m_vectors{e.m_vectors},
+          m_moduleRows{e.m_moduleRows},
+          m_moduleCols{e.m_moduleCols} {}
+    const DCRTModuleType& operator=(const DCRTModuleType& rhs) override {
+        m_params     = rhs.m_params;
+        m_format     = rhs.m_format;
+        m_vectors    = rhs.m_vectors;
+        m_moduleRows = rhs.m_moduleRows;
+        m_moduleCols = rhs.m_moduleCols;
+        return *this;
+    }
+
+    /**
+   * @brief Clone the object by making a copy of it and returning the copy
+   * @return new Element
+   */
+    DCRTModuleType Clone() const final {
+        return DCRTModuleType(*this);
+    }
+
+    /**
+ * @brief Clone the object, but have it contain nothing
+ * @return new Element
+ */
+    DCRTModuleType CloneEmpty() const final {
+        OPENFHE_THROW("CloneEmpty not implemented");
+    }
+
+    /**
+ * @brief Clones the element's parameters, leaves vector initialized to 0
+ * @return new Element
+ */
+    DCRTModuleType CloneParametersOnly() const final {
+        OPENFHE_THROW("CloneParametersOnly not implemented");
+    }
+
+    /**
+ * @brief Clones the element with parameters and with noise for the vector
+ * @param dgg
+ * @param format
+ * @return new Element
+ */
+    DCRTModuleType CloneWithNoise(const DiscreteGaussianGeneratorImpl<VecType>& dgg, Format format) const {
+        OPENFHE_THROW("CloneWithNoise not implemented");
+    };
+
+    // Assignment operators
+    /**
+ * @brief Assignment operator that copies elements.
+ * @param rhs
+ */
+    const DCRTModuleType& operator=(DCRTModuleType&& rhs) override {
+        m_params     = std::move(rhs.m_params);
+        m_format     = std::move(rhs.m_format);
+        m_vectors    = std::move(rhs.m_vectors);
+        m_moduleRows = std::move(rhs.m_moduleRows);
+        m_moduleCols = std::move(rhs.m_moduleCols);
+        return *this;
+    }
+    /**
+ * @brief Assignment operator that copies elements.
+ * @param rhs
+ */
+    const DCRTModuleType& operator=(std::initializer_list<uint64_t> rhs) override {
+        OPENFHE_THROW("operator= not implemented");
+    }
+
+    // GETTERS
+    /**
+ * @brief Get format of the element
+ *
+ * @return Format is either COEFFICIENT or EVALUATION
+ */
+    Format GetFormat() const {
+        return m_format;
+    }
+
+    /**
+ * @brief Get the length of the element.
+ *
+ * @return length
+ */
+    usint GetLength() const {
+        return m_moduleRows;
+    }
+
+    usint GetModuleRows() const {
+        return m_moduleRows;
+    }
+
+    usint GetModuleCols() const {
+        return m_moduleCols;
+    }
+
+    /**
+ * @brief Get modulus of the element
+ *
+ * @return the modulus.
+ */
+    const Integer& GetModulus() const {
+        return m_params->GetModulus();
+    };
+    /**
+ * @brief Get the cyclotomic order
+ *
+ * @return order
+ */
+    usint GetCyclotomicOrder() const {
+        return m_params->GetCyclotomicOrder();
+    }
+
+    const VecType& GetValues() const {
+        OPENFHE_THROW("GetValues not implemented for DCRTModule");
+    }
+
+    const usint GetRingDimension() const {
+        return m_params->GetRingDimension();
+    }
+
+    /**
+     * @brief Unary negation on a lattice
+     * @return -lattice
+     */
+    DCRTModuleType operator-() const {
+        return DCRTModuleType(m_params, m_format, true, m_moduleRows, m_moduleCols) -= *this;
+    }
+
+    DCRTModuleType Negate() const {
+        return DCRTModuleType(m_params, m_format, true, m_moduleRows, m_moduleCols) -= *this;
+    }
+
+    /**
+ * @brief Scalar addition - add an element
+ *
+ * @param &element is the element to add entry-wise.
+ * @return is the return of the addition operation.
+ */
+    DCRTModuleType Plus(const Integer& element) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i] + element;
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Scalar subtraction - subtract an element frp, all entries.
+ *
+ * @param &element is the element to subtract entry-wise.
+ * @return is the return value of the minus operation.
+ */
+    DCRTModuleType Minus(const Integer& element) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i] - element;
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Scalar multiplication - multiply all entries.
+ *
+ * @param &element is the element to multiply entry-wise.
+ * @return is the return value of the times operation.
+ */
+    DCRTModuleType Times(const Integer& element) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i] * element;
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Scalar multiplication - multiply all entries.
+ *
+ * @param &element is the element to multiply entry-wise.
+ * @return is the return value of the times operation.
+ */
+    DCRTModuleType Times(const std::vector<Integer>& crtElement) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i] * crtElement;
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Scalar multiplication - mulltiply by a signed integer
+ *
+ * @param &element is the element to multiply entry-wise.
+ * @return is the return value of the times operation.
+ */
+    DCRTModuleType Times(NativeInteger::SignedNativeInt element) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i] * element;
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Performs an addition operation and returns the result.
+ *
+ * @param &element is the element to add with.
+ * @return is the result of the addition.
+ */
+    DCRTModuleType Plus(const DCRTModuleType& element) const {
+        if (m_moduleCols != element.m_moduleCols || m_moduleRows != element.m_moduleRows) {
+            OPENFHE_THROW("Size mismatch");
+        }
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i] + element.m_vectors[i];
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Performs a subtraction operation and returns the result.
+ *
+ * @param &element is the element to subtract with.
+ * @return is the result of the subtraction.
+ */
+    DCRTModuleType Minus(const DCRTModuleType& element) const {
+        if (m_moduleCols != element.m_moduleCols || m_moduleRows != element.m_moduleRows) {
+            OPENFHE_THROW("Size mismatch");
+        }
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i] - element.m_vectors[i];
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Performs a multiplication operation and returns the result.
+ *
+ * @param &element is the element to multiply with.
+ * @return is the result of the multiplication.
+ */
+    DCRTModuleType Times(const DCRTModuleType& element) const {
+        if (m_moduleRows == 1 && m_moduleCols == 1) {
+            DCRTModuleType tmp(m_params, m_format, false, element.m_moduleRows, element.m_moduleCols);
+            for (usint i = 0; i < element.m_vectors.size(); i++) {
+                tmp.m_vectors[i] = m_vectors[0] * element.m_vectors[i];
+            }
+            return tmp;
+        }
+        else if (element.m_moduleRows == 1 && element.m_moduleCols == 1) {
+            DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+            for (usint i = 0; i < m_vectors.size(); i++) {
+                tmp.m_vectors[i] = m_vectors[i] * element.m_vectors[0];
+            }
+            return tmp;
+        }
+
+        if (m_moduleCols != element.m_moduleRows) {
+            OPENFHE_THROW("Times size mismatch");
+        }
+
+        DCRTModuleType tmp(m_params, m_format, true, m_moduleRows, element.m_moduleCols);
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(tmp.m_moduleRows))
+        for (usint row = 0; row < tmp.m_moduleRows; row++) {
+            for (usint col = 0; col < tmp.m_moduleCols; col++) {
+                for (usint i = 0; i < m_moduleCols; i++) {
+                    tmp.m_vectors[row * tmp.m_moduleCols + col] +=
+                        m_vectors[row * m_moduleCols + i] * element.m_vectors[i * element.m_moduleCols + col];
+                }
+            }
+        }
+        return tmp;
+    }
+
+    DCRTModuleType HadamardProduct(const DCRTModuleType& element) const {
+        if (m_moduleCols != element.m_moduleCols || m_moduleRows != element.m_moduleRows) {
+            OPENFHE_THROW("HadamardProduct size mismatch");
+        }
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        for (usint i = 0; i < m_vectors.size(); i++) {
+            tmp.m_vectors[i] = m_vectors[i] * element.m_vectors[i];
+        }
+        return tmp;
+    }
+
+    DCRTModuleType LowerTriangleProduct(const DCRTModuleType& element) const {
+        if ((m_moduleCols != 1 && m_moduleRows != 1) || m_moduleRows != element.m_moduleRows ||
+            m_moduleCols != element.m_moduleCols) {
+            OPENFHE_THROW("LowerTriangleProduct size mismatch");
+        }
+        int rows = m_moduleRows * (m_moduleRows - 1) / 2;
+        int cols = 1;
+        if (m_moduleRows == 1) {
+            rows = 1;
+            cols = m_moduleCols * (m_moduleCols - 1) / 2;
+        }
+        DCRTModuleType tmp(m_params, m_format, false, rows, cols);
+        int k = 0;
+        for (usint i = 0; i < m_vectors.size(); i++) {
+            for (usint j = i + 1; j < m_vectors.size(); j++) {
+                tmp.m_vectors[k++] = m_vectors[i] * element.m_vectors[j];
+            }
+        }
+        return tmp;
+    }
+
+    // overloaded op= operators
+    /**
+ * @brief Performs += operation with a Integer and returns the result.
+ *
+ * @param &element is the element to add
+ * @return is the result of the addition.
+ */
+    const DCRTModuleType& operator+=(const Integer& element) {
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            m_vectors[i] += element;
+        }
+        return *this;
+    }
+
+    /**
+ * @brief Performs -= operation with a Integer and returns the result.
+ *
+ * @param &element is the element to subtract
+ * @return is the result of the addition.
+ */
+    const DCRTModuleType& operator-=(const Integer& element) {
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            m_vectors[i] -= element;
+        }
+        return *this;
+    }
+
+    /**
+ * @brief Performs *= operation with a Integer and returns the result.
+ *
+ * @param &element is the element to multiply by
+ * @return is the result of the multiplication.
+ */
+    const DCRTModuleType& operator*=(const Integer& element) {
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            m_vectors[i] *= element;
+        }
+        return *this;
+    }
+
+    /**
+ * @brief Performs an addition operation and returns the result.
+ *
+ * @param &element is the element to add
+ * @return is the result of the addition.
+ */
+    const DCRTModuleType& operator+=(const DCRTModuleType& element) {
+        if (m_moduleCols != element.m_moduleCols || m_moduleRows != element.m_moduleRows) {
+            OPENFHE_THROW("Size mismatch");
+        }
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            m_vectors[i] += element.m_vectors[i];
+        }
+        return *this;
+    }
+
+    /**
+ * @brief Performs an subtraction operation and returns the result.
+ *
+ * @param &element is the element to subtract
+ * @return is the result of the addition.
+ */
+    const DCRTModuleType& operator-=(const DCRTModuleType& element) {
+        if (m_moduleCols != element.m_moduleCols || m_moduleRows != element.m_moduleRows) {
+            OPENFHE_THROW("Size mismatch");
+        }
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            m_vectors[i] -= element.m_vectors[i];
+        }
+        return *this;
+    }
+
+    /**
+ * @brief Performs an multiplication operation and returns the result.
+ *
+ * @param &element is the element to multiply by
+ * @return is the result of the multiplication.
+ */
+    const DCRTModuleType& operator*=(const DCRTModuleType& element) {
+        OPENFHE_THROW("operator*= not implemented");
+    }
+
+    /**
+ * @brief Equality operator.  Compares values of element to be compared to.
+ * @param element the element to compare to.
+ */
+    bool operator==(const DCRTModuleType& rhs) const {
+        return ((m_format == rhs.m_format) && (m_params->GetCyclotomicOrder() == rhs.m_params->GetCyclotomicOrder()) &&
+                (m_params->GetModulus() == rhs.m_params->GetModulus()) && (m_vectors.size() == rhs.m_vectors.size()) &&
+                (m_vectors == rhs.m_vectors) && (m_moduleCols == rhs.m_moduleCols));
+    }
+
+    /**
+ * @brief Inequality operator.  Compares values of element to be compared to.
+ * @param element the element to compare to.
+ */
+    inline bool operator!=(const DCRTModuleType& element) const {
+        return !(*this == element);
+    }
+
+    /**
+ * @brief Adds one to every entry of the Element, in place
+ */
+    void AddILElementOne() {
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            m_vectors[i].AddILElementOne();
+        }
+    }
+
+    void DropLastElement() {
+        for (auto& v : m_vectors)
+            v.DropLastElement();
+        Params* newP = new Params(*m_params);
+        newP->PopLastParam();
+        m_params.reset(newP);
+    }
+
+    void DropLastElements(size_t i) {
+        for (auto& v : m_vectors)
+            v.DropLastElements(i);
+        Params* newP = new Params(*m_params);
+        for (size_t j = 0; j < i; ++j)
+            newP->PopLastParam();
+        m_params.reset(newP);
+    }
+
+    // used for CKKS rescaling
+    void DropLastElementAndScale(const std::vector<NativeInteger>& QlQlInvModqlDivqlModq,
+                                 const std::vector<NativeInteger>& qlInvModq) {
+        for (auto& v : m_vectors)
+            v.DropLastElementAndScale(QlQlInvModqlDivqlModq, qlInvModq);
+        Params* newP = new Params(*m_params);
+        newP->PopLastParam();
+        m_params.reset(newP);
+    }
+
+    usint GetNumOfElements() const {
+        return m_vectors[0].GetNumOfElements();
+    }
+
+    /**
+ * @brief Performs an automorphism transform operation and returns the result.
+ *
+ * @param &i is the element to perform the automorphism transform with.
+ * @return is the result of the automorphism transform.
+ */
+    DCRTModuleType AutomorphismTransform(uint32_t i) const {
+        OPENFHE_THROW("AutomorphismTransform not implemented");
+    }
+
+    /**
+ * @brief Performs an automorphism transform operation using precomputed bit
+ * reversal indices.
+ *
+ * @param &i is the element to perform the automorphism transform with.
+ * @param &vec a vector with precomputed indices
+ * @return is the result of the automorphism transform.
+ */
+    DCRTModuleType AutomorphismTransform(uint32_t i, const std::vector<uint32_t>& vec) const {
+        OPENFHE_THROW("AutomorphismTransform not implemented");
+    }
+
+    /**
+ * @brief Transpose the ring element using the automorphism operation
+ *
+ * @return is the result of the transposition.
+ */
+    DCRTModuleType Transpose() const {
+        OPENFHE_THROW("Transpose not implemented");
+    }
+
+    /**
+ * @brief Write the element as \f$ \sum\limits{i=0}^{\lfloor {\log q/base}
+ * \rfloor} {(base^i u_i)} \f$ and return the vector of \f$ \left\{u_0,
+ * u_1,...,u_{\lfloor {\log q/base} \rfloor} \right\} \in R_{{base}^{\lceil
+ * {\log q/base} \rceil}} \f$; This is used as a subroutine in the
+ * relinearization procedure.
+ *
+ * @param baseBits is the number of bits in the base, i.e., base = 2^baseBits
+ * @param evalModeAnswer - if true, convert the resultant polynomials to
+ * evaluation mode
+ * @result is the pointer where the base decomposition vector is stored
+ */
+    std::vector<DCRTModuleType> BaseDecompose(usint baseBits, bool evalModeAnswer) const {
+        OPENFHE_THROW("BaseDecompose not implemented");
+    }
+
+    /**
+ * @brief Scalar division followed by rounding operation - operation on all
+ * entries.
+ *
+ * @param &q is the element to divide entry-wise.
+ * @return is the return value of the divide, followed by rounding operation.
+ */
+    DCRTModuleType DivideAndRound(const Integer& q) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i].DivideAndRound(q);
+        }
+        return tmp;
+    }
+
+    DCRTModuleType ApproxModDown(
+        const std::shared_ptr<Params>& paramsQ, const std::shared_ptr<Params>& paramsP,
+        const std::vector<NativeInteger>& PInvModq, const std::vector<NativeInteger>& PInvModqPrecon,
+        const std::vector<NativeInteger>& PHatInvModp, const std::vector<NativeInteger>& PHatInvModpPrecon,
+        const std::vector<std::vector<NativeInteger>>& PHatModq, const std::vector<DoubleNativeInt>& modqBarrettMu,
+        const std::vector<NativeInteger>& tInvModp, const std::vector<NativeInteger>& tInvModpPrecon,
+        const NativeInteger& t, const std::vector<NativeInteger>& tModqPrecon) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] =
+                m_vectors[i].ApproxModDown(paramsQ, paramsP, PInvModq, PInvModqPrecon, PHatInvModp, PHatInvModpPrecon,
+                                           PHatModq, modqBarrettMu, tInvModp, tInvModpPrecon, t, tModqPrecon);
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Determines if inverse exists
+ *
+ * @return true if there exists a multiplicative inverse.
+ */
+    bool InverseExists() const {
+        OPENFHE_THROW("InverseExists not implemented");
+    }
+
+    /**
+ * @brief Returns the infinity norm, basically the largest value in the ring
+ * element.
+ *
+ * @return the largest value in the ring element.
+ */
+    double Norm() const {
+        OPENFHE_THROW("Norm not implemented");
+    }
+
+    /**
+ * @brief Returns true if the vector is empty/ m_values==nullptr
+ *
+ * @return true if the vector is empty and all values nullptr.  false
+ * otherwise.
+ */
+    bool IsEmpty() const {
+        OPENFHE_THROW("IsEmpty not implemented");
+    }
+
+    /**
+ * @brief Make the element Sparse for SHE KeyGen operations.
+ * Sets every index not equal to zero mod the wFactor to zero.
+ *
+ * @param &wFactor ratio between the original element's ring dimension and the
+ * new ring dimension.
+ */
+    void MakeSparse(uint32_t wFactor) {
+        OPENFHE_THROW("MakeSparse not implemented");
+    }
+
+    /**
+ * @brief Calculate Element mod 2
+ *
+ * @return result of performing a mod-2 operation on the element.
+ */
+    DCRTModuleType ModByTwo() const {
+        OPENFHE_THROW("ModByTwo not implemented");
+    }
+
+    /**
+ * @brief Calculate and return the Multiplicative Inverse of the element
+ * @return the multiplicative inverse of the element, if it exists.
+ */
+    DCRTModuleType MultiplicativeInverse() const {
+        OPENFHE_THROW("MultiplicativeInverse not implemented");
+    }
+
+    /**
+ * @brief Scalar multiplication followed by division and rounding operation -
+ * operation on all entries.
+ *
+ * @param &p is the integer muliplicand.
+ * @param &q is the integer divisor.
+ * @return is the return value of the multiply, divide and followed by
+ * rounding operation.
+ */
+    DCRTModuleType MultiplyAndRound(const Integer& p, const Integer& q) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i].MultiplyAndRound(p, q);
+        }
+        return tmp;
+    }
+
+    /**
+ * @brief Calculate a vector of elements by raising the base element to
+ * successive powers
+ *
+ * @param baseBits
+ * @return
+ */
+    std::vector<DCRTModuleType> PowersOfBase(usint baseBits) const {
+        OPENFHE_THROW("PowersOfBase not implemented");
+    }
+
+    /**
+ * @brief Mod - perform a modulus operation.
+ * Does proper mapping of [-modulus/2, modulus/2) to [0, modulus).
+ *
+ * @param modulus is the modulus to use.
+ * @return is the return value of the modulus.
+ */
+    DCRTModuleType Mod(const Integer& modulus) const {
+        DCRTModuleType tmp(m_params, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i].Mod(modulus);
+        }
+        return tmp;
+    }
+
+    DCRTPolyType GetDCRTPolyAt(uint32_t index) const {
+        return m_vectors[index];
+    }
+
+    DCRTModuleType DropRows(uint32_t rowsToDrop, DCRTModuleType& removed) const {
+        if (rowsToDrop >= m_moduleRows) {
+            OPENFHE_THROW("DropRows rows to drop is >= current rows");
+        }
+
+        DCRTModuleType reduced(m_params, m_format, false, m_moduleRows - rowsToDrop, m_moduleCols);
+        for (usint row = 0; row < m_moduleRows - rowsToDrop; row++) {
+            for (usint col = 0; col < m_moduleCols; col++) {
+                reduced.m_vectors[row * m_moduleCols + col] = m_vectors[row * m_moduleCols + col];
+            }
+        }
+
+        removed = DCRTModuleType(m_params, m_format, false, rowsToDrop, m_moduleCols);
+        for (usint row = 0; row < rowsToDrop; row++) {
+            for (usint col = 0; col < m_moduleCols; col++) {
+                removed.m_vectors[row * m_moduleCols + col] =
+                    m_vectors[(m_moduleRows - rowsToDrop + row) * m_moduleCols + col];
+            }
+        }
+        return reduced;
+    }
+
+    DCRTModuleType DropColumns(uint32_t columnsToDrop, DCRTModuleType& removed) const {
+        if (columnsToDrop >= m_moduleCols) {
+            OPENFHE_THROW("DropRows rows to drop is >= current rows");
+        }
+
+        DCRTModuleType reduced(m_params, m_format, false, m_moduleRows, m_moduleCols - columnsToDrop);
+        for (usint row = 0; row < m_moduleRows; row++) {
+            for (usint col = 0; col < m_moduleCols - columnsToDrop; col++) {
+                reduced.m_vectors[row * (m_moduleCols - columnsToDrop) + col] = m_vectors[row * m_moduleCols + col];
+            }
+        }
+
+        removed = DCRTModuleType(m_params, m_format, false, m_moduleRows, columnsToDrop);
+        for (usint row = 0; row < m_moduleRows; row++) {
+            for (usint col = 0; col < columnsToDrop; col++) {
+                removed.m_vectors[row * (m_moduleCols - columnsToDrop) + col] =
+                    m_vectors[row * m_moduleCols + m_moduleCols - columnsToDrop + col];
+            }
+        }
+        return reduced;
+    }
+
+    /**
+ * @brief Switch modulus and adjust the values
+ *
+ * @param &modulus is the modulus to be set.
+ * @param &rootOfUnity is the corresponding root of unity for the modulus
+ * @param &modulusArb is the modulus used for arbitrary cyclotomics CRT
+ * @param &rootOfUnityArb is the corresponding root of unity for the modulus
+ * ASSUMPTION: This method assumes that the caller provides the correct
+ * rootOfUnity for the modulus.
+ */
+    void SwitchModulus(const Integer& modulus, const Integer& rootOfUnity, const Integer& modulusArb,
+                       const Integer& rootOfUnityArb) {
+        OPENFHE_THROW("SwitchModulus not implemented");
+    }
+
+    /**
+ * @brief onvert from Coefficient to CRT or vice versa; calls FFT and inverse FFT.
+ */
+    void SwitchFormat() {
+        m_format = (m_format == Format::COEFFICIENT) ? Format::EVALUATION : Format::COEFFICIENT;
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (size_t i = 0; i < size; ++i)
+            m_vectors[i].SwitchFormat();
+    }
+
+    std::string SerializedObjectName() const override {
+        return "DCRTModule";
+    }
+
+    inline const std::shared_ptr<Params>& GetParams() const {
+        return m_params;
+    }
+
+    const PolyType& GetElementAtIndex(size_t row, size_t col, usint i) const {
+        return m_vectors[row * m_moduleCols + col].GetElementAtIndex(i);
+    }
+
+    void SetElementAtIndex(size_t row, size_t col, usint index, const PolyType& element) {
+        m_vectors[row * m_moduleCols + col].SetElementAtIndex(index, element);
+    }
+
+    DCRTModuleType ApproxSwitchCRTBasis(const std::shared_ptr<Params>& paramsQ, const std::shared_ptr<Params>& paramsP,
+                                        const std::vector<NativeInteger>& QHatInvModq,
+                                        const std::vector<NativeInteger>& QHatInvModqPrecon,
+                                        const std::vector<std::vector<NativeInteger>>& QHatModp,
+                                        const std::vector<DoubleNativeInt>& modpBarrettMu) const {
+        DCRTModuleType tmp(paramsP, m_format, false, m_moduleRows, m_moduleCols);
+        size_t size{m_vectors.size()};
+        // #pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))
+        for (usint i = 0; i < size; i++) {
+            tmp.m_vectors[i] = m_vectors[i].ApproxSwitchCRTBasis(paramsQ, paramsP, QHatInvModq, QHatInvModqPrecon,
+                                                                 QHatModp, modpBarrettMu);
+        }
+        return tmp;
+    }
+
+    std::shared_ptr<Params> GetExtendedCRTBasis(const std::shared_ptr<Params>& paramsP) const {
+        size_t sizeQ  = m_params->GetParams().size();
+        size_t sizeQP = sizeQ + paramsP->GetParams().size();
+        std::vector<NativeInteger> moduliQP(sizeQP);
+        std::vector<NativeInteger> rootsQP(sizeQP);
+        const auto& parq = m_params->GetParams();
+        for (size_t i = 0; i < sizeQ; ++i) {
+            moduliQP[i] = parq[i]->GetModulus();
+            rootsQP[i]  = parq[i]->GetRootOfUnity();
+        }
+        const auto& parp = paramsP->GetParams();
+        for (size_t i = sizeQ, j = 0; i < sizeQP; ++i, ++j) {
+            moduliQP[i] = parp[j]->GetModulus();
+            rootsQP[i]  = parp[j]->GetRootOfUnity();
+        }
+        return std::make_shared<Params>(2 * m_params->GetRingDimension(), moduliQP, rootsQP);
+    }
+
+protected:
+    /**
+   * @brief ostream operator
+   * @param os the input preceding output stream
+   * @param vec the element to add to the output stream.
+   * @return a resulting concatenated output stream
+   */
+    friend inline std::ostream& operator<<(std::ostream& os, const DCRTModuleType& vec) {
+        // os << (vec.m_format == EVALUATION ? "EVAL: " : "COEF: ");
+        for (usint i = 0; i < vec.m_vectors.size(); i++) {
+            if (i != 0)
+                os << std::endl;
+            os << i << ": ";
+            os << vec.m_vectors[i] << "||";
+        }
+        return os;
+    }
+
+    /**
+   * @brief Element-element addition operator.
+   * @param a first element to add.
+   * @param b second element to add.
+   * @return the result of the addition operation.
+   */
+    friend inline DCRTModuleType operator+(const DCRTModuleType& a, const DCRTModuleType& b) {
+        return a.Plus(b);
+    }
+    /**
+   * @brief Element-integer addition operator.
+   * @param a first element to add.
+   * @param b integer to add.
+   * @return the result of the addition operation.
+   */
+    friend inline DCRTModuleType operator+(const DCRTModuleType& a, const Integer& b) {
+        return a.Plus(b);
+    }
+
+    /**
+   * @brief Integer-element addition operator.
+   * @param a integer to add.
+   * @param b element to add.
+   * @return the result of the addition operation.
+   */
+    friend inline DCRTModuleType operator+(const Integer& a, const DCRTModuleType& b) {
+        return b.Plus(a);
+    }
+
+    /**
+   * @brief Element-integer addition operator with CRT integer.
+   * @param a first element to add.
+   * @param b integer to add.
+   * @return the result of the addition operation.
+   */
+    friend inline DCRTModuleType operator+(const DCRTModuleType& a, const std::vector<Integer>& b) {
+        return a.Plus(b);
+    }
+
+    /**
+   * @brief Integer-element addition operator with CRT integer.
+   * @param a integer to add.
+   * @param b element to add.
+   * @return the result of the addition operation.
+   */
+    friend inline DCRTModuleType operator+(const std::vector<Integer>& a, const DCRTModuleType& b) {
+        return b.Plus(a);
+    }
+
+    /**
+   * @brief Element-element subtraction operator.
+   * @param a element to subtract from.
+   * @param b element to subtract.
+   * @return the result of the subtraction operation.
+   */
+    friend inline DCRTModuleType operator-(const DCRTModuleType& a, const DCRTModuleType& b) {
+        return a.Minus(b);
+    }
+
+    /**
+   * @brief Element-integer subtraction operator with CRT integer.
+   * @param a first element to subtract.
+   * @param b integer to subtract.
+   * @return the result of the subtraction operation.
+   */
+    friend inline DCRTModuleType operator-(const DCRTModuleType& a, const std::vector<Integer>& b) {
+        return a.Minus(b);
+    }
+
+    /**
+   * @brief Integer-element subtraction operator with CRT integer.
+   * @param a integer to subtract.
+   * @param b element to subtract.
+   * @return the result of the subtraction operation.
+   */
+    friend inline DCRTModuleType operator-(const std::vector<Integer>& a, const DCRTModuleType& b) {
+        return b.Minus(a);
+    }
+
+    /**
+   * @brief Element-integer subtraction operator.
+   * @param a element to subtract from.
+   * @param b integer to subtract.
+   * @return the result of the subtraction operation.
+   */
+    friend inline DCRTModuleType operator-(const DCRTModuleType& a, const Integer& b) {
+        return a.Minus(b);
+    }
+
+    /**
+   * @brief Element-element multiplication operator.
+   * @param a element to multiply.
+   * @param b element to multiply.
+   * @return the result of the multiplication operation.
+   */
+    friend inline DCRTModuleType operator*(const DCRTModuleType& a, const DCRTModuleType& b) {
+        return a.Times(b);
+    }
+
+    /**
+   * @brief Element-integer multiplication operator.
+   * @param a element to multiply.
+   * @param b integer to multiply.
+   * @return the result of the multiplication operation.
+   */
+    friend inline DCRTModuleType operator*(const DCRTModuleType& a, const Integer& b) {
+        return a.Times(b);
+    }
+
+    /**
+   * @brief Element-CRT number multiplication operator.
+   * @param a element to multiply.
+   * @param b integer to multiply, in CRT format.
+   * @return the result of the multiplication operation.
+   */
+    friend inline DCRTModuleType operator*(const DCRTModuleType& a, const std::vector<Integer>& b) {
+        return a.Times(b);
+    }
+
+    /**
+   * @brief Integer-element multiplication operator.
+   * @param a integer to multiply.
+   * @param b element to multiply.
+   * @return the result of the multiplication operation.
+   */
+    friend inline DCRTModuleType operator*(const Integer& a, const DCRTModuleType& b) {
+        return b.Times(a);
+    }
+
+    /**
+   * @brief Element-signed-integer multiplication operator.
+   * @param a element to multiply.
+   * @param b integer to multiply.
+   * @return the result of the multiplication operation.
+   */
+    friend inline DCRTModuleType operator*(const DCRTModuleType& a, int64_t b) {
+        return a.Times((NativeInteger::SignedNativeInt)b);
+    }
+
+    /**
+   * @brief signed-Integer-element multiplication operator.
+   * @param a integer to multiply.
+   * @param b element to multiply.
+   * @return the result of the multiplication operation.
+   */
+    friend inline DCRTModuleType operator*(int64_t a, const DCRTModuleType& b) {
+        return b.Times((NativeInteger::SignedNativeInt)a);
+    }
+
+protected:
+    std::shared_ptr<Params> m_params{std::make_shared<Params>()};
+    Format m_format{Format::EVALUATION};
+    std::vector<DCRTPolyType> m_vectors;
+    uint32_t m_moduleRows{1};
+    uint32_t m_moduleCols{1};
+};
+
+}  // namespace lbcrypto
+
+#endif
diff --git a/src/core/include/lattice/hal/lat-backend.h b/src/core/include/lattice/hal/lat-backend.h
index b09d3d5..494fdbe 100644
--- a/src/core/include/lattice/hal/lat-backend.h
+++ b/src/core/include/lattice/hal/lat-backend.h
@@ -45,11 +45,13 @@
 #define MAKE_ILDCRTPARAMS_TYPE(T) template class ILDCRTParams<T>;
 #define MAKE_POLY_TYPE(T)         template class PolyImpl<T>;
 #define MAKE_DCRTPOLY_TYPE(T)     template class DCRTPolyImpl<T>;
+#define MAKE_DCRTMODULE_TYPE(T)   template class DCRTModuleImpl<T>;
 
 #include "lattice/hal/default/ilparams.h"
 #include "lattice/hal/default/ildcrtparams.h"
 #include "lattice/hal/default/poly.h"
 #include "lattice/hal/default/dcrtpoly.h"
+#include "lattice/hal/default/dcrtmodule.h"
 
 namespace lbcrypto {
 
@@ -58,6 +60,7 @@ using ILParams       = ILParamsImpl<BigInteger>;
 using Poly           = PolyImpl<BigVector>;
 using NativePoly     = PolyImpl<NativeVector>;
 using DCRTPoly       = DCRTPolyImpl<BigVector>;
+using DCRTModule     = DCRTModuleImpl<BigVector>;
 
 #ifdef WITH_BE2
 using M2Params     = ILParamsImpl<M2Integer>;
diff --git a/src/core/lib/lattice/lattice.cpp b/src/core/lib/lattice/lattice.cpp
index 34b256e..e5d2f64 100644
--- a/src/core/lib/lattice/lattice.cpp
+++ b/src/core/lib/lattice/lattice.cpp
@@ -86,6 +86,7 @@ MAKE_ILPARAMS_TYPE(M2Integer)
 MAKE_ILDCRTPARAMS_TYPE(M2Integer)
 MAKE_POLY_TYPE(M2Vector)
 MAKE_DCRTPOLY_TYPE(M2Vector)
+MAKE_DCRTMODULE_TYPE(M2Vector)
 
 template class Matrix<M2Poly>;
 SPLIT64_FOR_TYPE(M2Poly)
@@ -120,6 +121,7 @@ MAKE_ILPARAMS_TYPE(M4Integer)
 MAKE_ILDCRTPARAMS_TYPE(M4Integer)
 MAKE_POLY_TYPE(M4Vector)
 MAKE_DCRTPOLY_TYPE(M4Vector)
+MAKE_DCRTMODULE_TYPE(M4Vector)
 
 template class Matrix<M4Poly>;
 SPLIT64_FOR_TYPE(M4Poly)
@@ -154,6 +156,7 @@ MAKE_ILPARAMS_TYPE(M6Integer)
 MAKE_ILDCRTPARAMS_TYPE(M6Integer)
 MAKE_POLY_TYPE(M6Vector)
 MAKE_DCRTPOLY_TYPE(M6Vector)
+MAKE_DCRTMODULE_TYPE(M6Vector)
 
 template class Matrix<M6Poly>;
 SPLIT64_FOR_TYPE(M6Poly)
diff --git a/src/pke/examples/simple-real-numbers-mod.cpp b/src/pke/examples/simple-real-numbers-mod.cpp
new file mode 100644
index 0000000..51002b6
--- /dev/null
+++ b/src/pke/examples/simple-real-numbers-mod.cpp
@@ -0,0 +1,146 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+  Simple examples for ModHE
+ */
+
+#define PROFILE
+
+#include "openfhe.h"
+
+using namespace lbcrypto;
+
+int main() {
+    // Step 1: Setup CryptoContext
+    uint32_t multDepth    = 2;
+    uint32_t scaleModSize = 50;
+    uint32_t batchSize    = 8;
+    uint32_t moduleRank   = 4;
+    CCParams<CryptoContextCKKSMod> parameters;
+ 
+    parameters.SetSecurityLevel(HEStd_128_classic);
+    parameters.SetMultiplicativeDepth(multDepth);
+    parameters.SetScalingModSize(scaleModSize);
+    parameters.SetBatchSize(batchSize);
+    parameters.SetModuleRank(moduleRank);
+    parameters.SetScalingTechnique(FLEXIBLEAUTOEXT);
+
+    CryptoContext<DCRTModule> cc = GenCryptoContext(parameters);
+
+    // Enable the features that you wish to use
+    cc->Enable(PKE);
+    cc->Enable(LEVELEDSHE);
+    cc->Enable(KEYSWITCH);
+    std::cout << "CKKSMod scheme is using ring dimension " << cc->GetRingDimension() << std::endl << std::endl;
+
+    // Step 2: Key Generation
+    auto keys = cc->KeyGen();
+
+    // Generate the relinearization keys
+    cc->EvalMultModKeyGen(keys.secretKey);
+
+    // Step 3: Encoding and encryption of inputs
+
+    // Inputs
+    std::vector<double> x1 = {0.25, 0.5, 0.75, 1.0, 2.0, 3.0, 4.0, 5.0};
+    std::vector<double> x2 = {5.0, 4.0, 3.0, 2.0, 1.0, 0.75, 0.5, 0.25};
+
+    // Encoding as plaintexts
+    Plaintext ptxt1 = cc->MakeCKKSPackedPlaintext(x1);
+    Plaintext ptxt2 = cc->MakeCKKSPackedPlaintext(x2);
+
+    std::cout << "Input x1: " << ptxt1 << std::endl;
+    std::cout << "Input x2: " << ptxt2 << std::endl;
+
+    // Encrypt the encoded vectors
+    auto c1 = cc->Encrypt(keys.publicKey, ptxt1);
+    auto c2 = cc->Encrypt(keys.publicKey, ptxt2);
+
+    // Step 4: Evaluation
+
+    // Homomorphic addition
+    auto cAdd = cc->EvalAdd(c1, c2);
+
+    // Homomorphic subtraction
+    auto cSub = cc->EvalSub(c1, c2);
+
+    // Homomorphic multiplication
+    auto cMul1 = cc->EvalMultAndRelinearize(c1, c2);
+
+    // Rank reduction
+    int reducedRank = 2;
+    PrivateKey<DCRTModule> reducedKey;
+    auto rankredKey = cc->EvalRankRedKeyGen(keys.secretKey, reducedKey, reducedRank);
+    auto cMulRed = cc->EvalRankReduce(cMul1, rankredKey);
+
+    // Step 5: Decryption and output
+    Plaintext result;
+    // We set the cout precision to 8 decimal digits for a nicer output.
+    // If you want to see the error/noise introduced by CKKS, bump it up
+    // to 15 and it should become visible.
+    std::cout.precision(8);
+
+    std::cout << std::endl << "Results of homomorphic computations: " << std::endl;
+
+    cc->Decrypt(keys.secretKey, c1, &result);
+    result->SetLength(batchSize);
+    std::cout << "x1 = " << result;
+
+    cc->Decrypt(keys.secretKey, c2, &result);
+    result->SetLength(batchSize);
+    std::cout << "x2 = " << result;
+
+    std::cout << "Estimated precision in bits: " << result->GetLogPrecision() << std::endl;
+
+    // Decrypt the result of addition
+    cc->Decrypt(keys.secretKey, cAdd, &result);
+    result->SetLength(batchSize);
+    std::cout << "x1 + x2 = " << result;
+    std::cout << "Estimated precision in bits: " << result->GetLogPrecision() << std::endl;
+
+    // Decrypt the result of subtraction
+    cc->Decrypt(keys.secretKey, cSub, &result);
+    result->SetLength(batchSize);
+    std::cout << "x1 - x2 = " << result << std::endl;
+
+    // Decrypt the result of multiplication
+    cc->Decrypt(keys.secretKey, cMul1, &result);
+    result->SetLength(batchSize);
+    std::cout << "mul: x1 * x2 = " << result << std::endl;
+
+    // Decrypt the result of rank reduction
+    cc->Decrypt(reducedKey, cMulRed, &result);
+    result->SetLength(batchSize);
+    std::cout << "reduced multiplication result: x1 * x2 = " << result << std::endl;
+
+    return 0;
+}
diff --git a/src/pke/include/ciphertext-ser.h b/src/pke/include/ciphertext-ser.h
index 54b650d..247add8 100644
--- a/src/pke/include/ciphertext-ser.h
+++ b/src/pke/include/ciphertext-ser.h
@@ -42,6 +42,7 @@
 extern template class lbcrypto::CiphertextImpl<lbcrypto::Poly>;
 extern template class lbcrypto::CiphertextImpl<lbcrypto::NativePoly>;
 extern template class lbcrypto::CiphertextImpl<lbcrypto::DCRTPoly>;
+extern template class lbcrypto::CiphertextImpl<lbcrypto::DCRTModule>;
 
 CEREAL_CLASS_VERSION(lbcrypto::CiphertextImpl<lbcrypto::Poly>,
                      lbcrypto::CiphertextImpl<lbcrypto::Poly>::SerializedVersion());
@@ -49,5 +50,7 @@ CEREAL_CLASS_VERSION(lbcrypto::CiphertextImpl<lbcrypto::NativePoly>,
                      lbcrypto::CiphertextImpl<lbcrypto::NativePoly>::SerializedVersion());
 CEREAL_CLASS_VERSION(lbcrypto::CiphertextImpl<lbcrypto::DCRTPoly>,
                      lbcrypto::CiphertextImpl<lbcrypto::DCRTPoly>::SerializedVersion());
+CEREAL_CLASS_VERSION(lbcrypto::CiphertextImpl<lbcrypto::DCRTModule>,
+                     lbcrypto::CiphertextImpl<lbcrypto::DCRTModule>::SerializedVersion());
 
 #endif
diff --git a/src/pke/include/cryptocontext.h b/src/pke/include/cryptocontext.h
index 8c4413e..c5913c0 100644
--- a/src/pke/include/cryptocontext.h
+++ b/src/pke/include/cryptocontext.h
@@ -361,7 +361,7 @@ protected:
                                                       size_t noiseScaleDeg, uint32_t level,
                                                       const std::shared_ptr<ParmType> params, usint slots) const {
         VerifyCKKSScheme(__func__);
-        const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersRNS>(GetCryptoParameters());
+        const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersRNSImpl<Element>>(GetCryptoParameters());
         if (level > 0) {
             // validation of level: We need to compare it to multiplicativeDepth, but multiplicativeDepth is not
             // readily available. so, what we get is numModuli and use it for calculations
@@ -1718,6 +1718,26 @@ public:
    */
     void EvalMultKeyGen(const PrivateKey<Element> key);
 
+    /**
+   * EvalMultKeyGen creates all relinearization key (s^2, s0s1, etc.) that can be used with the OpenFHE EvalMult
+   * operator for CKKSMod
+   * the new evaluation keys are stored in cryptocontext
+   * @param key secret key
+   */
+    void EvalMultModKeyGen(const PrivateKey<Element> key);
+
+    /**
+   * EvalRankRedKeyGen creates a key to be used for EvalRankRed operation
+   * operator for CKKSMod
+   * the new evaluation keys are stored in cryptocontext
+   * @param key secret key
+   */
+    EvalKey<Element> EvalRankRedKeyGen(const PrivateKey<Element> key, PrivateKey<Element>& reducedKey, usint newRank);
+
+    Ciphertext<Element> EvalRankReduce(ConstCiphertext<Element> ciphertext, EvalKey<Element> reduceKey) const {
+        return GetScheme()->EvalRankReduce(ciphertext, reduceKey);
+    }
+
     /**
    * EvalMultsKeyGen creates a vector evalmult keys that can be used with the
    * OpenFHE EvalMult operator 1st key (for s^2) is used for multiplication of
diff --git a/src/pke/include/cryptocontextfactory.h b/src/pke/include/cryptocontextfactory.h
index 3cca987..d2a8369 100644
--- a/src/pke/include/cryptocontextfactory.h
+++ b/src/pke/include/cryptocontextfactory.h
@@ -88,6 +88,9 @@ public:
 template <>
 std::vector<CryptoContext<DCRTPoly>> CryptoContextFactory<DCRTPoly>::AllContexts;
 
+template <>
+std::vector<CryptoContext<DCRTModule>> CryptoContextFactory<DCRTModule>::AllContexts;
+
 }  // namespace lbcrypto
 
 #endif
diff --git a/src/pke/include/encoding/plaintext.h b/src/pke/include/encoding/plaintext.h
index efd18cc..69e4aef 100644
--- a/src/pke/include/encoding/plaintext.h
+++ b/src/pke/include/encoding/plaintext.h
@@ -72,6 +72,7 @@ protected:
     mutable Poly encodedVector;
     mutable NativePoly encodedNativeVector;
     mutable DCRTPoly encodedVectorDCRT;
+    mutable std::shared_ptr<DCRTModule> encodedVectorDCRTModule;
 
     static constexpr int intCTOR     = 0x01;
     static constexpr int vecintCTOR  = 0x02;
@@ -481,6 +482,24 @@ inline DCRTPoly& PlaintextImpl::GetElement<DCRTPoly>() {
     return encodedVectorDCRT;
 }
 
+/**
+ * GetElement
+ * @return the DCRTModule that the element was encoded into
+ */
+template <>
+inline const DCRTModule& PlaintextImpl::GetElement<DCRTModule>() const {
+    if (encodedVectorDCRTModule == nullptr)
+        encodedVectorDCRTModule = std::make_shared<DCRTModule>(encodedVectorDCRT);
+    return *encodedVectorDCRTModule;
+}
+
+template <>
+inline DCRTModule& PlaintextImpl::GetElement<DCRTModule>() {
+    if (encodedVectorDCRTModule == nullptr)
+        encodedVectorDCRTModule = std::make_shared<DCRTModule>(encodedVectorDCRT);
+    return *encodedVectorDCRTModule;
+}
+
 }  // namespace lbcrypto
 
 #endif
diff --git a/src/pke/include/keyswitch/keyswitch-mod.h b/src/pke/include/keyswitch/keyswitch-mod.h
new file mode 100644
index 0000000..3540df1
--- /dev/null
+++ b/src/pke/include/keyswitch/keyswitch-mod.h
@@ -0,0 +1,113 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+/**
+ * Hybrid key switching method first introduced in https://eprint.iacr.org/2012/099.pdf
+ * RNS version was introduced in https://eprint.iacr.org/2019/688.
+ * See the Appendix of https://eprint.iacr.org/2021/204 for more detailed description.
+
+* GHS Keyswitching :
+    Pros : Smaller noise growth than BV and is more efficient as it only
+               requires a linear number of NTTs
+               Cons : need to double dimension,N, or reduce size of ciphertext modulus, Q, by a factor of 2
+
+*/
+#ifndef LBCRYPTO_CRYPTO_KEYSWITCH_MOD_H
+#define LBCRYPTO_CRYPTO_KEYSWITCH_MOD_H
+
+#include "keyswitch/keyswitch-rns.h"
+#include "schemebase/rlwe-cryptoparameters.h"
+
+#include <string>
+#include <vector>
+#include <memory>
+
+/**
+ * @namespace lbcrypto
+ * The namespace of lbcrypto
+ */
+namespace lbcrypto {
+
+class KeySwitchMod : public KeySwitchBase<DCRTModule> {
+    using ParmType = typename DCRTModule::Params;
+    using DugType  = typename DCRTModule::DugType;
+    using DggType  = typename DCRTModule::DggType;
+    using TugType  = typename DCRTModule::TugType;
+
+public:
+    KeySwitchMod() {};
+
+    virtual ~KeySwitchMod() {};
+
+    EvalKey<DCRTModule> KeySwitchGenInternal(const PrivateKey<DCRTModule> oldPrivateKey,
+                                             const PrivateKey<DCRTModule> newPrivateKey,
+                                             const EvalKey<DCRTModule> ekPrev) const override;
+
+    EvalKey<DCRTModule> KeySwitchGenInternal(const PrivateKey<DCRTModule> oldPrivateKey,
+                                             const PrivateKey<DCRTModule> newPrivateKey) const override;
+
+    void KeySwitchInPlace(Ciphertext<DCRTModule>& ciphertext, const EvalKey<DCRTModule> ek) const;
+
+    std::shared_ptr<std::vector<DCRTModule>> EvalKeySwitchPrecomputeCore(
+        const DCRTModule& c, std::shared_ptr<CryptoParametersBase<DCRTModule>> cryptoParamsBase) const;
+
+    std::shared_ptr<std::vector<DCRTModule>> EvalFastKeySwitchCore(
+        const std::shared_ptr<std::vector<DCRTModule>> digits, const EvalKey<DCRTModule> evalKey,
+        const std::shared_ptr<ParmType> paramsQl) const;
+
+    std::shared_ptr<std::vector<DCRTModule>> EvalFastKeySwitchCoreExt(
+        const std::shared_ptr<std::vector<DCRTModule>> digits, const EvalKey<DCRTModule> evalKey,
+        const std::shared_ptr<ParmType> paramsQl) const;
+
+    std::shared_ptr<std::vector<DCRTModule>> KeySwitchCore(const DCRTModule& a,
+                                                           const EvalKey<DCRTModule> evalKey) const override;
+
+    /////////////////////////////////////////
+    // SERIALIZATION
+    /////////////////////////////////////////
+
+    template <class Archive>
+    void save(Archive& ar) const {
+        ar(cereal::base_class<KeySwitchRNS>(this));
+    }
+
+    template <class Archive>
+    void load(Archive& ar) {
+        ar(cereal::base_class<KeySwitchRNS>(this));
+    }
+
+    std::string SerializedObjectName() const {
+        return "KeySwitchMod";
+    }
+};
+
+}  // namespace lbcrypto
+
+#endif
diff --git a/src/pke/include/openfhe.h b/src/pke/include/openfhe.h
index a1ea17f..0b2e6e8 100644
--- a/src/pke/include/openfhe.h
+++ b/src/pke/include/openfhe.h
@@ -68,9 +68,11 @@
 
 #include "scheme/bfvrns/bfvrns-scheme.h"
 #include "scheme/ckksrns/ckksrns-scheme.h"
+#include "scheme/ckksmod/ckksmod-scheme.h"
 
 #include "gen-cryptocontext.h"
 #include "scheme/ckksrns/gen-cryptocontext-ckksrns.h"
+#include "scheme/ckksmod/gen-cryptocontext-ckksmod.h"
 #include "scheme/bfvrns/gen-cryptocontext-bfvrns.h"
 #include "scheme/bgvrns/gen-cryptocontext-bgvrns.h"
 
diff --git a/src/pke/include/scheme/ckksmod/ckksmod-cryptoparameters.h b/src/pke/include/scheme/ckksmod/ckksmod-cryptoparameters.h
new file mode 100644
index 0000000..a831053
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/ckksmod-cryptoparameters.h
@@ -0,0 +1,130 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+#ifndef LBCRYPTO_CRYPTO_CKKSMOD_CRYPTOPARAMETERS_H
+#define LBCRYPTO_CRYPTO_CKKSMOD_CRYPTOPARAMETERS_H
+
+#include "schemerns/rns-cryptoparameters.h"
+#include "globals.h"
+
+#include <memory>
+#include <string>
+
+/**
+ * @namespace lbcrypto
+ * The namespace of lbcrypto
+ */
+namespace lbcrypto {
+
+class CryptoParametersCKKSMod : public CryptoParametersMod {
+    using ParmType = typename DCRTModule::Params;
+
+public:
+    CryptoParametersCKKSMod() : CryptoParametersMod() {}
+
+    CryptoParametersCKKSMod(const CryptoParametersCKKSMod& rhs) : CryptoParametersMod(rhs) {}
+
+    CryptoParametersCKKSMod(std::shared_ptr<ParmType> params, const PlaintextModulus& plaintextModulus,
+                            float distributionParameter, float assuranceMeasure, SecurityLevel securityLevel,
+                            usint digitSize, SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2,
+                            KeySwitchTechnique ksTech = BV, ScalingTechnique scalTech = FIXEDMANUAL,
+                            EncryptionTechnique encTech = STANDARD, MultiplicationTechnique multTech = HPS,
+                            MultipartyMode multipartyMode                         = FIXED_NOISE_MULTIPARTY,
+                            ExecutionMode executionMode                           = EXEC_EVALUATION,
+                            DecryptionNoiseMode decryptionNoiseMode               = FIXED_NOISE_DECRYPT,
+                            COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK)
+        : CryptoParametersMod(params, plaintextModulus, distributionParameter, assuranceMeasure, securityLevel,
+                              digitSize, secretKeyDist, maxRelinSkDeg, ksTech, scalTech, encTech, multTech,
+                              multipartyMode, executionMode, decryptionNoiseMode, mPIntBootCiphertextCompressionLevel) {
+    }
+
+    CryptoParametersCKKSMod(std::shared_ptr<ParmType> params, EncodingParams encodingParams,
+                            float distributionParameter, float assuranceMeasure, SecurityLevel securityLevel,
+                            usint digitSize, SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2,
+                            KeySwitchTechnique ksTech = BV, ScalingTechnique scalTech = FIXEDMANUAL,
+                            EncryptionTechnique encTech = STANDARD, MultiplicationTechnique multTech = HPS,
+                            ProxyReEncryptionMode PREMode           = NOT_SET,
+                            MultipartyMode multipartyMode           = FIXED_NOISE_MULTIPARTY,
+                            ExecutionMode executionMode             = EXEC_EVALUATION,
+                            DecryptionNoiseMode decryptionNoiseMode = FIXED_NOISE_DECRYPT,
+                            PlaintextModulus noiseScale = 1, uint32_t statisticalSecurity = 30,
+                            uint32_t numAdversarialQueries = 1, uint32_t thresholdNumOfParties = 1,
+                            COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK,
+                            uint32_t moduleRank = 1)
+        : CryptoParametersMod(params, encodingParams, distributionParameter, assuranceMeasure, securityLevel, digitSize,
+                              secretKeyDist, maxRelinSkDeg, ksTech, scalTech, encTech, multTech, PREMode,
+                              multipartyMode, executionMode, decryptionNoiseMode, noiseScale, statisticalSecurity,
+                              numAdversarialQueries, thresholdNumOfParties, mPIntBootCiphertextCompressionLevel,
+                              moduleRank) {}
+
+    virtual ~CryptoParametersCKKSMod() {}
+
+    void PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech, EncryptionTechnique encTech,
+                             MultiplicationTechnique multTech, uint32_t numPartQ, uint32_t auxBits,
+                             uint32_t extraBits) override;
+
+    uint64_t FindAuxPrimeStep() const override;
+
+    /////////////////////////////////////
+    // SERIALIZATION
+    /////////////////////////////////////
+
+    template <class Archive>
+    void save(Archive& ar, std::uint32_t const version) const {
+        ar(cereal::base_class<CryptoParametersMod>(this));
+    }
+
+    template <class Archive>
+    void load(Archive& ar, std::uint32_t const version) {
+        if (version > SerializedVersion()) {
+            std::string errMsg("serialized object version " + std::to_string(version) +
+                               " is from a later version of the library");
+            OPENFHE_THROW(errMsg);
+        }
+        ar(cereal::base_class<CryptoParametersMod>(this));
+
+        if (PrecomputeCRTTablesAfterDeserializaton()) {
+            PrecomputeCRTTables(m_ksTechnique, m_scalTechnique, m_encTechnique, m_multTechnique, m_numPartQ, m_auxBits,
+                                m_extraBits);
+        }
+    }
+
+    std::string SerializedObjectName() const override {
+        return "CryptoParametersCKKSMod";
+    }
+    static uint32_t SerializedVersion() {
+        return 1;
+    }
+};
+
+}  // namespace lbcrypto
+
+#endif
diff --git a/src/pke/include/scheme/ckksmod/ckksmod-leveledshe.h b/src/pke/include/scheme/ckksmod/ckksmod-leveledshe.h
new file mode 100644
index 0000000..463d2da
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/ckksmod-leveledshe.h
@@ -0,0 +1,125 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+#ifndef LBCRYPTO_CRYPTO_CKKSMOD_LEVELEDSHE_H
+#define LBCRYPTO_CRYPTO_CKKSMOD_LEVELEDSHE_H
+
+#include "schemebase/base-leveledshe.h"
+
+#include <memory>
+#include <string>
+#include <map>
+#include <vector>
+
+/**
+ * @namespace lbcrypto
+ * The namespace of lbcrypto
+ */
+namespace lbcrypto {
+
+class LeveledSHECKKSMod : public LeveledSHEBase<DCRTModule> {
+public:
+    virtual ~LeveledSHECKKSMod() {}
+
+    void EvalAddInPlace(Ciphertext<DCRTModule>& ciphertext1, ConstCiphertext<DCRTModule> ciphertext2) const override;
+
+    void EvalSubInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                           ConstCiphertext<DCRTModule> ciphertext2) const override;
+
+    Ciphertext<DCRTModule> EvalMult(ConstCiphertext<DCRTModule> ciphertext1,
+                                    ConstCiphertext<DCRTModule> ciphertext2) const override;
+
+    Ciphertext<DCRTModule> EvalMult(ConstCiphertext<DCRTModule> ciphertext1, ConstCiphertext<DCRTModule> ciphertext2,
+                                    const EvalKey<DCRTModule> evalKey) const override {
+        OPENFHE_THROW("EvalMult with evalKey not supported for this scheme");  // Needs more than one evalKey
+    }
+
+    Ciphertext<DCRTModule> EvalMultCore(ConstCiphertext<DCRTModule> ciphertext1,
+                                        ConstCiphertext<DCRTModule> ciphertext2) const override;
+
+    void EvalMultCoreInPlace(Ciphertext<DCRTModule>& ciphertext, double operand) const;
+
+    EvalKey<DCRTModule> EvalMultKeyGen(const PrivateKey<DCRTModule> privateKey) const {
+        OPENFHE_THROW(
+            "EvalMultKeyGen not supported for this scheme use EvalMultModKeyGen instead");  // Needs more than one evalKey
+    }
+
+    std::vector<EvalKey<DCRTModule>> EvalMultModKeyGen(const PrivateKey<DCRTModule> privateKey) const override;
+
+    EvalKey<DCRTModule> EvalRankRedKeyGen(const PrivateKey<DCRTModule> privateKey, PrivateKey<DCRTModule>& reducedKey, usint newRank) const override;
+
+    Ciphertext<DCRTModule> EvalRankReduce(ConstCiphertext<DCRTModule> ciphertext, EvalKey<DCRTModule> reduceKey) const override;
+
+    void AdjustLevelsAndDepthInPlace(Ciphertext<DCRTModule>& ciphertext1, Ciphertext<DCRTModule>& ciphertext2) const;
+
+    void AdjustLevelsAndDepthToOneInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                          Ciphertext<DCRTModule>& ciphertext2) const override;
+
+    Ciphertext<DCRTModule> ModReduce(ConstCiphertext<DCRTModule> ciphertext, size_t levels) const override;
+
+    void ModReduceInPlace(Ciphertext<DCRTModule>& ciphertext, size_t levels) const override;
+
+    void ModReduceInternalInPlace(Ciphertext<DCRTModule>& ciphertext, size_t levels) const override;
+
+    void LevelReduceInternalInPlace(Ciphertext<DCRTModule>& ciphertext, size_t levels) const override;
+
+    std::vector<DCRTModule::Integer> GetElementForEvalMult(ConstCiphertext<DCRTModule> ciphertext,
+                                                           double operand) const;
+
+    void AdjustLevelsInPlace(Ciphertext<DCRTModule>& ciphertext1, Ciphertext<DCRTModule>& ciphertext2) const override;
+
+    void AdjustForAddOrSubInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                  Ciphertext<DCRTModule>& ciphertext2) const override;
+
+    void AdjustForMultInPlace(Ciphertext<DCRTModule>& ciphertext1, Ciphertext<DCRTModule>& ciphertext2) const override;
+
+    /////////////////////////////////////
+    // SERIALIZATION
+    /////////////////////////////////////
+
+    template <class Archive>
+    void save(Archive& ar) const {
+        ar(cereal::base_class<LeveledSHEBase<DCRTModule>>(this));
+    }
+
+    template <class Archive>
+    void load(Archive& ar) {
+        ar(cereal::base_class<LeveledSHEBase<DCRTModule>>(this));
+    }
+
+    std::string SerializedObjectName() const {
+        return "LeveledSHECKKSMod";
+    }
+};
+
+}  // namespace lbcrypto
+
+#endif
diff --git a/src/pke/include/scheme/ckksmod/ckksmod-parametergeneration.h b/src/pke/include/scheme/ckksmod/ckksmod-parametergeneration.h
new file mode 100644
index 0000000..052b4b2
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/ckksmod-parametergeneration.h
@@ -0,0 +1,77 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+#ifndef LBCRYPTO_CRYPTO_CKKSMOD_PARAMETERGENERATION_H
+#define LBCRYPTO_CRYPTO_CKKSMOD_PARAMETERGENERATION_H
+
+#include "schemebase/base-parametergeneration.h"
+
+#include <string>
+#include <memory>
+
+/**
+ * @namespace lbcrypto
+ * The namespace of lbcrypto
+ */
+namespace lbcrypto {
+
+class ParameterGenerationCKKSMod : public ParameterGenerationBase<DCRTModule> {
+public:
+    virtual ~ParameterGenerationCKKSMod() {}
+
+    bool ParamsGenCKKSMod(std::shared_ptr<CryptoParametersBase<DCRTModule>> cryptoParams, usint cyclOrder,
+                          usint numPrimes, usint scalingModSize, usint firstModSize, uint32_t mulPartQ,
+                          COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel, usint moduleRank) const override;
+
+    /////////////////////////////////////
+    // SERIALIZATION
+    /////////////////////////////////////
+
+    template <class Archive>
+    void save(Archive& ar, std::uint32_t const version) const {}
+
+    template <class Archive>
+    void load(Archive& ar, std::uint32_t const version) {}
+
+    std::string SerializedObjectName() const {
+        return "ParameterGenerationCKKSRNS";
+    }
+
+protected:
+    enum DCRT_MODULUS {
+        DEFAULT_EXTRA_MOD_SIZE = 20,
+        MIN_SIZE               = 14,
+        MAX_SIZE               = 60,
+    };
+};
+
+};  // namespace lbcrypto
+#endif
diff --git a/src/pke/include/scheme/ckksmod/ckksmod-pke.h b/src/pke/include/scheme/ckksmod/ckksmod-pke.h
new file mode 100644
index 0000000..87266cc
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/ckksmod-pke.h
@@ -0,0 +1,132 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+#ifndef LBCRYPTO_CRYPTO_CKKSMOD_PKE_H
+#define LBCRYPTO_CRYPTO_CKKSMOD_PKE_H
+
+#include "schemebase/base-pke.h"
+#include "lattice/lat-hal.h"
+
+#include <string>
+
+/**
+ * @namespace lbcrypto
+ * The namespace of lbcrypto
+ */
+namespace lbcrypto {
+
+class PKECKKSMOD : public PKEBase<DCRTModule> {
+    using ParmType = typename DCRTModule::Params;
+    using IntType  = typename DCRTModule::Integer;
+    using DugType  = typename DCRTModule::DugType;
+    using DggType  = typename DCRTModule::DggType;
+    using TugType  = typename DCRTModule::TugType;
+
+public:
+    virtual ~PKECKKSMOD() {}
+
+    KeyPair<DCRTModule> KeyGenInternal(CryptoContext<DCRTModule> cc, bool makeSparse) const override;
+
+    /**
+   * Method for encrypting plaintext using LBC
+   *
+   * @param&publicKey public key used for encryption.
+   * @param plaintext copy of the plaintext element. NOTE a copy is passed!
+   * That is NOT an error!
+   * @param doEncryption encrypts if true, embeds (encodes) the plaintext into
+   * cryptocontext if false
+   * @param *ciphertext ciphertext which results from encryption.
+   */
+    Ciphertext<DCRTModule> Encrypt(DCRTModule plaintext, const PublicKey<DCRTModule> publicKey) const override;
+
+    /**
+ * Method for encrypting plaintex using LBC
+ *
+ * @param privateKey private key used for encryption.
+ * @param plaintext copy of the plaintext input. NOTE a copy is passed! That
+ * is NOT an error!
+ * @param doEncryption encrypts if true, embeds (encodes) the plaintext into
+ * cryptocontext if false
+ * @param *ciphertext ciphertext which results from encryption.
+ */
+    Ciphertext<DCRTModule> Encrypt(DCRTModule plaintext, const PrivateKey<DCRTModule> privateKey) const override;
+
+    /**
+   * Method for decrypting plaintext with noise flooding
+   *
+   * @param &privateKey private key used for decryption.
+   * @param &ciphertext ciphertext id decrypted.
+   * @param *plaintext the plaintext output.
+   * @return the decoding result.
+   */
+    DecryptResult Decrypt(ConstCiphertext<DCRTModule> ciphertext, const PrivateKey<DCRTModule> privateKey,
+                          NativePoly* plaintext) const override;
+
+    /**
+   * Method for decrypting plaintext with noise flooding
+   *
+   * @param &privateKey private key used for decryption.
+   * @param &ciphertext ciphertext id decrypted.
+   * @param *plaintext the plaintext output.
+   * @return the decoding result.
+   */
+    DecryptResult Decrypt(ConstCiphertext<DCRTModule> ciphertext, const PrivateKey<DCRTModule> privateKey,
+                          Poly* plaintext) const override;
+
+    std::shared_ptr<std::vector<DCRTModule>> EncryptZeroCore(const PrivateKey<DCRTModule> privateKey,
+                                                             const std::shared_ptr<ParmType> params) const override;
+
+    std::shared_ptr<std::vector<DCRTModule>> EncryptZeroCore(const PublicKey<DCRTModule> publicKey,
+                                                             const std::shared_ptr<ParmType> params) const override;
+
+    DCRTModule DecryptCore(const std::vector<DCRTModule>& cv, const PrivateKey<DCRTModule> privateKey) const override;
+    /////////////////////////////////////
+    // SERIALIZATION
+    /////////////////////////////////////
+
+    template <class Archive>
+    void save(Archive& ar) const {
+        ar(cereal::base_class<PKEBase<DCRTModule>>(this));
+    }
+
+    template <class Archive>
+    void load(Archive& ar) {
+        ar(cereal::base_class<PKEBase<DCRTModule>>(this));
+    }
+
+    std::string SerializedObjectName() const {
+        return "PKECKKSMOD";
+    }
+};
+
+}  // namespace lbcrypto
+
+#endif
diff --git a/src/pke/include/scheme/ckksmod/ckksmod-scheme.h b/src/pke/include/scheme/ckksmod/ckksmod-scheme.h
new file mode 100644
index 0000000..8d868e1
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/ckksmod-scheme.h
@@ -0,0 +1,85 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+#ifndef LBCRYPTO_CRYPTO_CKKSMOD_SCHEME_H
+#define LBCRYPTO_CRYPTO_CKKSMOD_SCHEME_H
+
+#include "schemebase/base-scheme.h"
+
+#include "scheme/ckksmod/ckksmod-leveledshe.h"
+#include "scheme/ckksmod/ckksmod-pke.h"
+#include "scheme/ckksmod/ckksmod-parametergeneration.h"
+
+#include <string>
+#include <memory>
+
+/**
+ * @namespace lbcrypto
+ * The namespace of lbcrypto
+ */
+namespace lbcrypto {
+
+class SchemeCKKSMod : public SchemeBase<DCRTModule> {
+public:
+    SchemeCKKSMod() {
+        this->m_ParamsGen = std::make_shared<ParameterGenerationCKKSMod>();
+    }
+
+    virtual ~SchemeCKKSMod() {}
+
+    bool operator==(const SchemeBase<DCRTModule>& sch) const override {
+        return dynamic_cast<const SchemeCKKSMod*>(&sch) != nullptr;
+    }
+
+    void Enable(PKESchemeFeature feature) override;
+
+    /////////////////////////////////////
+    // SERIALIZATION
+    /////////////////////////////////////
+
+    template <class Archive>
+    void save(Archive& ar, std::uint32_t const version) const {
+        ar(cereal::base_class<SchemeBase<DCRTModule>>(this));
+    }
+
+    template <class Archive>
+    void load(Archive& ar, std::uint32_t const version) {
+        ar(cereal::base_class<SchemeBase<DCRTModule>>(this));
+    }
+
+    std::string SerializedObjectName() const override {
+        return "SchemeCKKSMod";
+    }
+};
+
+}  // namespace lbcrypto
+
+#endif
diff --git a/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-internal.h b/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-internal.h
new file mode 100644
index 0000000..43eb564
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-internal.h
@@ -0,0 +1,145 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+  API to generate CKKS crypto context. MUST NOT (!) be used without a wrapper function
+ */
+
+#ifndef _GEN_CRYPTOCONTEXT_CKKSMOD_INTERNAL_H_
+#define _GEN_CRYPTOCONTEXT_CKKSMOD_INTERNAL_H_
+
+#include "encoding/encodingparams.h"
+#include "constants.h"
+#include "utils/exception.h"
+#include "scheme/scheme-utils.h"
+#include "scheme/scheme-id.h"
+
+#include <memory>
+
+namespace lbcrypto {
+
+// forward declarations (don't include headers as compilation fails when you do)
+template <typename T>
+class CCParams;
+
+template <typename ContextGeneratorType, typename Element>
+typename ContextGeneratorType::ContextType genCryptoContextCKKSModInternal(
+    const CCParams<ContextGeneratorType>& parameters) {
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+    if (parameters.GetScalingTechnique() == FLEXIBLEAUTO || parameters.GetScalingTechnique() == FLEXIBLEAUTOEXT) {
+        OPENFHE_THROW("128-bit CKKS is not supported for the FLEXIBLEAUTO or FLEXIBLEAUTOEXT methods.");
+    }
+#endif
+    using ParmType                   = typename Element::Params;
+    constexpr float assuranceMeasure = 36.0f;
+
+    auto ep = std::make_shared<ParmType>();
+
+    usint scalingModSize    = parameters.GetScalingModSize();
+    usint firstModSize      = parameters.GetFirstModSize();
+    double floodingNoiseStd = 0;
+    if (parameters.GetDecryptionNoiseMode() == NOISE_FLOODING_DECRYPT &&
+        parameters.GetExecutionMode() == EXEC_EVALUATION) {
+        if (parameters.GetNoiseEstimate() == 0) {
+            OPENFHE_THROW(
+                "Noise estimate must be set in the combination of NOISE_FLOODING_DECRYPT and EXEC_EVALUATION modes.");
+        }
+        double logstd =
+            parameters.GetStatisticalSecurity() / 2 + log2(sqrt(12 * parameters.GetNumAdversarialQueries()));
+        floodingNoiseStd = pow(2, logstd + parameters.GetNoiseEstimate());
+#if NATIVEINT == 128
+        scalingModSize = parameters.GetDesiredPrecision() + parameters.GetNoiseEstimate() + logstd +
+                         0.5 * log2(parameters.GetRingDim());
+        firstModSize = scalingModSize + 11;
+#else
+        scalingModSize = MAX_MODULUS_SIZE - 1;
+        firstModSize   = MAX_MODULUS_SIZE;
+        if (logstd + parameters.GetNoiseEstimate() > scalingModSize - 3) {
+            OPENFHE_THROW("Precision of less than 3 bits is not supported. logstd " + std::to_string(logstd) +
+                          " + noiseEstimate " + std::to_string(parameters.GetNoiseEstimate()) + " must be 56 or less.");
+        }
+#endif
+    }
+    EncodingParams encodingParams(std::make_shared<EncodingParamsImpl>(scalingModSize, parameters.GetBatchSize()));
+
+    // clang-format off
+    auto params = std::make_shared<typename ContextGeneratorType::CryptoParams>(
+        ep,
+        encodingParams,
+        parameters.GetStandardDeviation(),
+        assuranceMeasure,
+        parameters.GetSecurityLevel(),
+        parameters.GetDigitSize(),
+        parameters.GetSecretKeyDist(),
+        parameters.GetMaxRelinSkDeg(),
+        parameters.GetKeySwitchTechnique(),
+        parameters.GetScalingTechnique(),
+        parameters.GetEncryptionTechnique(),
+        parameters.GetMultiplicationTechnique(),
+        parameters.GetPREMode(),
+        parameters.GetMultipartyMode(),
+        parameters.GetExecutionMode(),
+        parameters.GetDecryptionNoiseMode(),
+        1,  // noise scale: TODO (dsuponit): this should be reviewed as we also call SetNoiseScale(1) (see below)
+        parameters.GetStatisticalSecurity(),
+        parameters.GetNumAdversarialQueries(),
+        parameters.GetThresholdNumOfParties(),
+        parameters.GetInteractiveBootCompressionLevel(),
+        parameters.GetModuleRank()
+    );
+
+    // for CKKS scheme noise scale is always set to 1
+    params->SetNoiseScale(1);
+    params->SetFloodingDistributionParameter(floodingNoiseStd);
+
+    uint32_t numLargeDigits =
+        ComputeNumLargeDigits(parameters.GetNumLargeDigits(), parameters.GetMultiplicativeDepth());
+
+    auto scheme = std::make_shared<typename ContextGeneratorType::PublicKeyEncryptionScheme>();
+    // scheme->SetKeySwitchingTechnique(parameters.GetKeySwitchTechnique());
+    scheme->ParamsGenCKKSMod(
+        params,
+        2 * parameters.GetRingDim(),
+        parameters.GetMultiplicativeDepth() + 1,
+        scalingModSize,
+        firstModSize,
+        numLargeDigits,
+        parameters.GetInteractiveBootCompressionLevel(),
+        parameters.GetModuleRank());
+    // clang-format on
+
+    auto cc = ContextGeneratorType::Factory::GetContext(params, scheme);
+    cc->setSchemeId(SCHEME::CKKSMOD_SCHEME);
+    return cc;
+}
+}  // namespace lbcrypto
+
+#endif  // _GEN_CRYPTOCONTEXT_CKKSMOD_INTERNAL_H_
diff --git a/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-params.h b/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-params.h
new file mode 100644
index 0000000..1502494
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod-params.h
@@ -0,0 +1,95 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+  Parameter class to generate CKKSMod crypto context
+ */
+
+#ifndef __GEN_CRYPTOCONTEXT_CKKSMOD_PARAMS_H__
+#define __GEN_CRYPTOCONTEXT_CKKSMOD_PARAMS_H__
+
+#include "scheme/gen-cryptocontext-params.h"
+
+#include <string>
+#include <vector>
+
+namespace lbcrypto {
+
+class CryptoContextCKKSMod;
+
+// every CCParams class should include the following forward declaration as there is
+// no general CCParams class template. This way we may create scheme specific classes
+// derived from Params or have them completely independent.
+template <typename T>
+class CCParams;
+//====================================================================================================================
+template <>
+class CCParams<CryptoContextCKKSMod> : public Params {
+public:
+    CCParams() : Params(CKKSMOD_SCHEME) {}
+    explicit CCParams(const std::vector<std::string>& vals) : Params(vals) {}
+    CCParams(const CCParams& obj) = default;
+    CCParams(CCParams&& obj)      = default;
+    ~CCParams()                   = default;
+
+    //================================================================================================================
+    // DISABLE FUNCTIONS that are not applicable to CKKSMod
+    //================================================================================================================
+    void SetPlaintextModulus(PlaintextModulus ptModulus0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+    void SetEvalAddCount(uint32_t evalAddCount0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+    void SetKeySwitchCount(uint32_t keySwitchCount0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+    void SetEncryptionTechnique(EncryptionTechnique encryptionTechnique0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+    void SetMultiplicationTechnique(MultiplicationTechnique multiplicationTechnique0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+    void SetPRENumHops(uint32_t PRENumHops0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+    void SetMultipartyMode(MultipartyMode multipartyMode0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+    void SetThresholdNumOfParties(uint32_t thresholdNumOfParties0) override {
+        DISABLED_FOR_CKKSMOD;
+    }
+};
+//====================================================================================================================
+
+}  // namespace lbcrypto
+
+#endif  // __GEN_CRYPTOCONTEXT_CKKSMOD_PARAMS_H__
diff --git a/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod.h b/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod.h
new file mode 100644
index 0000000..3666959
--- /dev/null
+++ b/src/pke/include/scheme/ckksmod/gen-cryptocontext-ckksmod.h
@@ -0,0 +1,66 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+  API to generate CKKSMod crypto context
+ */
+
+#ifndef __GEN_CRYPTOCONTEXT_CKKSMOD_H__
+#define __GEN_CRYPTOCONTEXT_CKKSMOD_H__
+
+#include "lattice/lat-hal.h"
+#include "scheme/ckksmod/gen-cryptocontext-ckksmod-internal.h"
+#include "scheme/ckksmod/gen-cryptocontext-ckksmod-params.h"
+#include "scheme/ckksmod/ckksmod-cryptoparameters.h"
+#include "scheme/ckksmod/ckksmod-scheme.h"
+#include "scheme/gen-cryptocontext-params-validation.h"
+#include "cryptocontextfactory.h"
+
+namespace lbcrypto {
+
+class CryptoContextCKKSMod {
+    using Element = DCRTModule;
+
+public:
+    using ContextType               = CryptoContext<Element>;  // required by GenCryptoContext() in gen-cryptocontext.h
+    using Factory                   = CryptoContextFactory<Element>;
+    using PublicKeyEncryptionScheme = SchemeCKKSMod;
+    using CryptoParams              = CryptoParametersCKKSMod;
+
+    static CryptoContext<Element> genCryptoContext(const CCParams<CryptoContextCKKSMod>& parameters) {
+        validateParametersForCryptocontext(parameters);
+        return genCryptoContextCKKSModInternal<CryptoContextCKKSMod, Element>(parameters);
+    }
+};
+
+}  // namespace lbcrypto
+
+#endif  // __GEN_CRYPTOCONTEXT_CKKSMOD_H__
diff --git a/src/pke/include/scheme/gen-cryptocontext-params-defaults.h b/src/pke/include/scheme/gen-cryptocontext-params-defaults.h
index 4d3f977..aff365d 100644
--- a/src/pke/include/scheme/gen-cryptocontext-params-defaults.h
+++ b/src/pke/include/scheme/gen-cryptocontext-params-defaults.h
@@ -81,6 +81,48 @@ constexpr uint32_t statisticalSecurity                      = 30;
 constexpr uint32_t numAdversarialQueries                    = 1;
 constexpr uint32_t thresholdNumOfParties                    = 1;
 constexpr COMPRESSION_LEVEL interactiveBootCompressionLevel = SLACK;
+constexpr uint32_t moduleRank                               = 1;
+};  // namespace CKKSRNS_SCHEME_DEFAULTS
+
+namespace CKKSMOD_SCHEME_DEFAULTS {
+constexpr SCHEME scheme               = CKKSRNS_SCHEME;
+constexpr PlaintextModulus ptModulus  = 0;
+constexpr uint32_t digitSize          = 0;
+constexpr float standardDeviation     = 3.19f;
+constexpr SecretKeyDist secretKeyDist = UNIFORM_TERNARY;
+constexpr uint32_t maxRelinSkDeg      = 2;
+constexpr KeySwitchTechnique ksTech   = HYBRID;
+// Backend-specific settings for CKKS
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+constexpr ScalingTechnique scalTech = FIXEDAUTO;
+constexpr uint32_t firstModSize     = 89;
+constexpr uint32_t scalingModSize   = 78;
+#else
+constexpr ScalingTechnique scalTech = FLEXIBLEAUTOEXT;
+constexpr uint32_t firstModSize     = 60;
+constexpr uint32_t scalingModSize   = 50;
+#endif
+constexpr uint32_t batchSize                                = 0;
+constexpr uint32_t numLargeDigits                           = 0;
+constexpr uint32_t multiplicativeDepth                      = 1;
+constexpr SecurityLevel securityLevel                       = HEStd_128_classic;
+constexpr uint32_t ringDim                                  = 0;
+constexpr uint32_t evalAddCount                             = 0;
+constexpr uint32_t keySwitchCount                           = 0;
+constexpr EncryptionTechnique encryptionTechnique           = STANDARD;
+constexpr MultiplicationTechnique multiplicationTechnique   = HPS;
+constexpr uint32_t PRENumHops                               = 0;
+constexpr ProxyReEncryptionMode PREMode                     = INDCPA;
+constexpr MultipartyMode multipartyMode                     = FIXED_NOISE_MULTIPARTY;
+constexpr ExecutionMode executionMode                       = EXEC_EVALUATION;
+constexpr DecryptionNoiseMode decryptionNoiseMode           = FIXED_NOISE_DECRYPT;
+constexpr double noiseEstimate                              = 0.0;
+constexpr double desiredPrecision                           = 25.0;
+constexpr uint32_t statisticalSecurity                      = 30;
+constexpr uint32_t numAdversarialQueries                    = 1;
+constexpr uint32_t thresholdNumOfParties                    = 1;
+constexpr COMPRESSION_LEVEL interactiveBootCompressionLevel = SLACK;
+constexpr uint32_t moduleRank                               = 2;
 };  // namespace CKKSRNS_SCHEME_DEFAULTS
 
 namespace BFVRNS_SCHEME_DEFAULTS {
@@ -99,7 +141,7 @@ constexpr uint32_t multiplicativeDepth = 1;
 #if defined(HAVE_INT128) || NATIVEINT != 64
 constexpr uint32_t scalingModSize = 60;
 #else
-constexpr uint32_t scalingModSize   = 57;
+constexpr uint32_t scalingModSize = 57;
 #endif
 constexpr SecurityLevel securityLevel                       = HEStd_128_classic;
 constexpr uint32_t ringDim                                  = 0;
@@ -118,6 +160,7 @@ constexpr uint32_t statisticalSecurity                      = 0;
 constexpr uint32_t numAdversarialQueries                    = 0;
 constexpr uint32_t thresholdNumOfParties                    = 1;
 constexpr COMPRESSION_LEVEL interactiveBootCompressionLevel = SLACK;
+constexpr uint32_t moduleRank                               = 1;
 };  // namespace BFVRNS_SCHEME_DEFAULTS
 
 namespace BGVRNS_SCHEME_DEFAULTS {
@@ -151,6 +194,7 @@ constexpr uint32_t statisticalSecurity                      = 30;
 constexpr uint32_t numAdversarialQueries                    = 1;
 constexpr uint32_t thresholdNumOfParties                    = 1;
 constexpr COMPRESSION_LEVEL interactiveBootCompressionLevel = SLACK;
+constexpr uint32_t moduleRank                               = 1;
 };  // namespace BGVRNS_SCHEME_DEFAULTS
 
 //====================================================================================================================
diff --git a/src/pke/include/scheme/gen-cryptocontext-params.h b/src/pke/include/scheme/gen-cryptocontext-params.h
index c78a8ed..db7c300 100644
--- a/src/pke/include/scheme/gen-cryptocontext-params.h
+++ b/src/pke/include/scheme/gen-cryptocontext-params.h
@@ -167,6 +167,8 @@ class Params {
     // COMPACT has stronger security assumption, thus more efficient
     COMPRESSION_LEVEL interactiveBootCompressionLevel;
 
+    uint32_t moduleRank;
+
     void SetToDefaults(SCHEME scheme);
 
 protected:
@@ -187,6 +189,7 @@ protected:
     //     DISABLED_FOR_CKKS;
     // }
 
+#define DISABLED_FOR_CKKSMOD OPENFHE_THROW("This function is not available for CKKSMod.");
 #define DISABLED_FOR_CKKSRNS OPENFHE_THROW("This function is not available for CKKSRNS.");
 #define DISABLED_FOR_BGVRNS  OPENFHE_THROW("This function is not available for BGVRNS.");
 #define DISABLED_FOR_BFVRNS  OPENFHE_THROW("This function is not available for BFVRNS.");
@@ -343,6 +346,9 @@ public:
     COMPRESSION_LEVEL GetInteractiveBootCompressionLevel() const {
         return interactiveBootCompressionLevel;
     }
+    uint32_t GetModuleRank() const {
+        return moduleRank;
+    }
 
     // setters
     // They all must be virtual, so any of them can be disabled in the derived class
@@ -433,6 +439,9 @@ public:
     virtual void SetInteractiveBootCompressionLevel(COMPRESSION_LEVEL interactiveBootCompressionLevel0) {
         interactiveBootCompressionLevel = interactiveBootCompressionLevel0;
     }
+    virtual void SetModuleRank(uint32_t moduleRank0) {
+        moduleRank = moduleRank0;
+    }
 
     friend std::ostream& operator<<(std::ostream& os, const Params& obj);
 };
diff --git a/src/pke/include/scheme/scheme-id.h b/src/pke/include/scheme/scheme-id.h
index e4cb4fe..6e6343d 100644
--- a/src/pke/include/scheme/scheme-id.h
+++ b/src/pke/include/scheme/scheme-id.h
@@ -45,6 +45,7 @@ namespace lbcrypto {
 enum SCHEME {
     INVALID_SCHEME = 0,
     CKKSRNS_SCHEME,
+    CKKSMOD_SCHEME,
     BFVRNS_SCHEME,
     BGVRNS_SCHEME,
 };
@@ -56,7 +57,7 @@ std::string convertToString(SCHEME schemeId) noexcept;
 std::ostream& operator<<(std::ostream& os, SCHEME schemeId);
 //====================================================================================================================
 inline bool isCKKS(SCHEME schemeId) {
-    return (schemeId == CKKSRNS_SCHEME);
+    return (schemeId == CKKSRNS_SCHEME) || (schemeId == CKKSMOD_SCHEME);
 }
 inline bool isBFVRNS(SCHEME schemeId) {
     return (schemeId == BFVRNS_SCHEME);
diff --git a/src/pke/include/schemebase/base-leveledshe.h b/src/pke/include/schemebase/base-leveledshe.h
index 2ab99da..b1fef69 100644
--- a/src/pke/include/schemebase/base-leveledshe.h
+++ b/src/pke/include/schemebase/base-leveledshe.h
@@ -304,6 +304,10 @@ public:
    */
     virtual EvalKey<Element> EvalMultKeyGen(const PrivateKey<Element> privateKey) const;
 
+    virtual std::vector<EvalKey<Element>> EvalMultModKeyGen(const PrivateKey<Element> privateKey) const {
+        OPENFHE_THROW("EvalMultModKeyGen is not implemented for this scheme");
+    }
+
     /**
    * Virtual function to define the interface for generating a evaluation key
    * which is used after each multiplication for depth more than 2.
@@ -435,11 +439,11 @@ public:
         OPENFHE_THROW("double scalar multiplication is not implemented for this scheme");
     }
 
-    virtual Ciphertext<DCRTPoly> MultByInteger(ConstCiphertext<DCRTPoly> ciphertext, uint64_t integer) const {
+    virtual Ciphertext<Element> MultByInteger(ConstCiphertext<Element> ciphertext, uint64_t integer) const {
         OPENFHE_THROW("MultByInteger is not implemented for this scheme");
     }
 
-    virtual void MultByIntegerInPlace(Ciphertext<DCRTPoly>& ciphertext, uint64_t integer) const {
+    virtual void MultByIntegerInPlace(Ciphertext<Element>& ciphertext, uint64_t integer) const {
         OPENFHE_THROW("MultByIntegerInPlace is not implemented for this scheme");
     }
 
@@ -639,6 +643,13 @@ public:
     /////////////////////////////////////////
     // SHE LEVELED Mod Reduce
     /////////////////////////////////////////
+    virtual EvalKey<Element> EvalRankRedKeyGen(const PrivateKey<Element> privateKey, PrivateKey<Element>& reducedKey, usint newRank) const {
+        OPENFHE_THROW("EvalRankRedKeyGen is not implemented for this scheme");
+    }
+
+    virtual Ciphertext<Element> EvalRankReduce(ConstCiphertext<Element> ciphertext, EvalKey<Element> reduceKey) const {
+        OPENFHE_THROW("EvalRankReduce is not implemented for this scheme");
+    }
 
     /**
    * Method for Modulus Reduction.
@@ -837,7 +848,7 @@ protected:
    * @param ciphertext2 second input ciphertext.
    * @return result of homomorphic multiplication of input ciphertexts.
    */
-    Ciphertext<Element> EvalMultCore(ConstCiphertext<Element> ciphertext1, ConstCiphertext<Element> ciphertext2) const;
+    virtual Ciphertext<Element> EvalMultCore(ConstCiphertext<Element> ciphertext1, ConstCiphertext<Element> ciphertext2) const;
 
     Ciphertext<Element> EvalSquareCore(ConstCiphertext<Element> ciphertext) const;
 
diff --git a/src/pke/include/schemebase/base-parametergeneration.h b/src/pke/include/schemebase/base-parametergeneration.h
index 4621f65..de6dbe4 100644
--- a/src/pke/include/schemebase/base-parametergeneration.h
+++ b/src/pke/include/schemebase/base-parametergeneration.h
@@ -103,6 +103,24 @@ public:
 
     /**
    * Method for computing all derived parameters based on chosen primitive
+   * parameters.
+   *
+   * @param *cryptoParams the crypto parameters object to be populated with
+   * parameters.
+   * @param cyclOrder the cyclotomic order.
+   * @param numPrimes number of modulus towers to support.
+   * @param scalingModSize the bit-width for plaintexts and DCRTPoly's.
+   * @param firstModSize the bit-size of the first modulus
+   * @param numPartQ number of partitions of Q for HYBRID key switching
+   */
+    virtual bool ParamsGenCKKSMod(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t cyclOrder,
+                                  uint32_t numPrimes, uint32_t scalingModSize, uint32_t firstModSize, uint32_t numPartQ,
+                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel, uint32_t moduleRank) const {
+        OPENFHE_THROW("This signature for ParamsGen is not supported for this scheme.");
+    }
+
+    /**
+   * Method for computing all derived parameters based on chosen primitive
    * parameters. This is intended for BGVrns
    * @param *cryptoParams the crypto parameters object to be populated with
    * parameters.
@@ -115,7 +133,7 @@ public:
    * @param numPartQ number of partitions of Q for HYBRID key switching
    * @param PRENumHops bound for the HRA-secure mode of PRE
    */
-    virtual bool ParamsGenBGVRNS(std::shared_ptr<CryptoParametersBase<DCRTPoly>> cryptoParams, uint32_t evalAddCount,
+    virtual bool ParamsGenBGVRNS(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t evalAddCount,
                                  uint32_t keySwitchCount, uint32_t cyclOrder, uint32_t numPrimes, uint32_t firstModSize,
                                  uint32_t dcrtBits, uint32_t numPartQ, uint32_t PRENumHops) const {
         OPENFHE_THROW("This signature for ParamsGen is not supported for this scheme.");
diff --git a/src/pke/include/schemebase/base-scheme.h b/src/pke/include/schemebase/base-scheme.h
index 736a7ed..156d83d 100644
--- a/src/pke/include/schemebase/base-scheme.h
+++ b/src/pke/include/schemebase/base-scheme.h
@@ -212,7 +212,16 @@ public:
                                              mPIntBootCiphertextCompressionLevel);
     }
 
-    virtual bool ParamsGenBGVRNS(std::shared_ptr<CryptoParametersBase<DCRTPoly>> cryptoParams, uint32_t evalAddCount,
+    virtual bool ParamsGenCKKSMod(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t cyclOrder,
+                                  uint32_t numPrimes, uint32_t scalingModSize, uint32_t firstModSize, uint32_t numPartQ,
+                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel, uint32_t moduleRank) const {
+        if (!m_ParamsGen)
+            OPENFHE_THROW("m_ParamsGen is nullptr");
+        return m_ParamsGen->ParamsGenCKKSMod(cryptoParams, cyclOrder, numPrimes, scalingModSize, firstModSize, numPartQ,
+                                             mPIntBootCiphertextCompressionLevel, moduleRank);
+    }
+
+    virtual bool ParamsGenBGVRNS(std::shared_ptr<CryptoParametersBase<Element>> cryptoParams, uint32_t evalAddCount,
                                  uint32_t keySwitchCount, uint32_t cyclOrder, uint32_t numPrimes, uint32_t firstModSize,
                                  uint32_t dcrtBits, uint32_t numPartQ, uint32_t PRENumHops) const {
         if (!m_ParamsGen)
@@ -641,6 +650,8 @@ public:
 
     virtual EvalKey<Element> EvalMultKeyGen(const PrivateKey<Element> privateKey) const;
 
+    virtual std::vector<EvalKey<Element>> EvalMultModKeyGen(const PrivateKey<Element> privateKey) const;
+
     virtual std::vector<EvalKey<Element>> EvalMultKeysGen(const PrivateKey<Element> privateKey) const;
 
     virtual Ciphertext<Element> EvalMult(ConstCiphertext<Element> ciphertext1,
@@ -852,14 +863,14 @@ public:
         return;
     }
 
-    virtual Ciphertext<DCRTPoly> MultByInteger(ConstCiphertext<DCRTPoly> ciphertext, uint64_t integer) const {
+    virtual Ciphertext<Element> MultByInteger(ConstCiphertext<Element> ciphertext, uint64_t integer) const {
         VerifyLeveledSHEEnabled(__func__);
         if (!ciphertext)
             OPENFHE_THROW("Input ciphertext is nullptr");
         return m_LeveledSHE->MultByInteger(ciphertext, integer);
     }
 
-    virtual void MultByIntegerInPlace(Ciphertext<DCRTPoly>& ciphertext, uint64_t integer) const {
+    virtual void MultByIntegerInPlace(Ciphertext<Element>& ciphertext, uint64_t integer) const {
         VerifyLeveledSHEEnabled(__func__);
         if (!ciphertext)
             OPENFHE_THROW("Input ciphertext is nullptr");
@@ -974,6 +985,10 @@ public:
     // SHE Leveled Methods Wrapper
     /////////////////////////////////////////
 
+    virtual EvalKey<Element> EvalRankRedKeyGen(const PrivateKey<Element> key, PrivateKey<Element>& reducedKey, usint newRank) const;
+
+    virtual Ciphertext<Element> EvalRankReduce(ConstCiphertext<Element> ciphertext, EvalKey<Element> reduceKey) const;
+
     virtual Ciphertext<Element> ComposedEvalMult(ConstCiphertext<Element> ciphertext1,
                                                  ConstCiphertext<Element> ciphertext2,
                                                  const EvalKey<Element> evalKey) const;
@@ -1046,7 +1061,7 @@ public:
         return m_LeveledSHE->Compress(ciphertext, towersLeft);
     }
 
-    virtual void AdjustLevelsInPlace(Ciphertext<DCRTPoly>& ciphertext1, Ciphertext<DCRTPoly>& ciphertext2) const {
+    virtual void AdjustLevelsInPlace(Ciphertext<Element>& ciphertext1, Ciphertext<Element>& ciphertext2) const {
         VerifyLeveledSHEEnabled(__func__);
         if (!ciphertext1)
             OPENFHE_THROW("Input ciphertext1 is nullptr");
@@ -1056,8 +1071,8 @@ public:
         return;
     }
 
-    virtual void AdjustLevelsAndDepthInPlace(Ciphertext<DCRTPoly>& ciphertext1,
-                                             Ciphertext<DCRTPoly>& ciphertext2) const {
+    virtual void AdjustLevelsAndDepthInPlace(Ciphertext<Element>& ciphertext1,
+                                             Ciphertext<Element>& ciphertext2) const {
         VerifyLeveledSHEEnabled(__func__);
         if (!ciphertext1)
             OPENFHE_THROW("Input ciphertext1 is nullptr");
@@ -1067,8 +1082,8 @@ public:
         return;
     }
 
-    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext<DCRTPoly>& ciphertext1,
-                                                  Ciphertext<DCRTPoly>& ciphertext2) const {
+    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext<Element>& ciphertext1,
+                                                  Ciphertext<Element>& ciphertext2) const {
         VerifyLeveledSHEEnabled(__func__);
         if (!ciphertext1)
             OPENFHE_THROW("Input ciphertext1 is nullptr");
@@ -1432,7 +1447,7 @@ public:
         return m_SchemeSwitch->EvalCKKStoFHEW(ciphertext, numCtxts);
     }
 
-    void EvalFHEWtoCKKSSetup(const CryptoContextImpl<DCRTPoly>& ccCKKS, const std::shared_ptr<BinFHEContext>& ccLWE,
+    void EvalFHEWtoCKKSSetup(const CryptoContextImpl<Element>& ccCKKS, const std::shared_ptr<BinFHEContext>& ccLWE,
                              uint32_t numSlotsCKKS = 0, uint32_t logQ = 25) {
         VerifySchemeSwitchEnabled(__func__);
         m_SchemeSwitch->EvalFHEWtoCKKSSetup(ccCKKS, ccLWE, numSlotsCKKS, logQ);
diff --git a/src/pke/include/schemebase/base-ser.h b/src/pke/include/schemebase/base-ser.h
index 8d8ddfc..1c6e191 100644
--- a/src/pke/include/schemebase/base-ser.h
+++ b/src/pke/include/schemebase/base-ser.h
@@ -44,12 +44,25 @@ extern template class lbcrypto::CryptoParametersRLWE<lbcrypto::DCRTPoly>;
 extern template class lbcrypto::SchemeBase<lbcrypto::DCRTPoly>;
 extern template class lbcrypto::FHEBase<lbcrypto::DCRTPoly>;
 
+extern template class lbcrypto::CryptoParametersBase<lbcrypto::DCRTModule>;
+extern template class lbcrypto::CryptoParametersRLWE<lbcrypto::DCRTModule>;
+extern template class lbcrypto::SchemeBase<lbcrypto::DCRTModule>;
+extern template class lbcrypto::FHEBase<lbcrypto::DCRTModule>;
+
 CEREAL_REGISTER_TYPE(lbcrypto::Serializable);
 CEREAL_REGISTER_TYPE(lbcrypto::CryptoParametersBase<lbcrypto::DCRTPoly>);
 CEREAL_REGISTER_TYPE(lbcrypto::CryptoParametersRLWE<lbcrypto::DCRTPoly>);
 CEREAL_REGISTER_TYPE(lbcrypto::SchemeBase<lbcrypto::DCRTPoly>);
 CEREAL_REGISTER_TYPE(lbcrypto::FHEBase<lbcrypto::DCRTPoly>);
 
+CEREAL_REGISTER_TYPE(lbcrypto::CryptoParametersBase<lbcrypto::DCRTModule>);
+CEREAL_REGISTER_TYPE(lbcrypto::CryptoParametersRLWE<lbcrypto::DCRTModule>);
+CEREAL_REGISTER_TYPE(lbcrypto::SchemeBase<lbcrypto::DCRTModule>);
+CEREAL_REGISTER_TYPE(lbcrypto::FHEBase<lbcrypto::DCRTModule>);
+
 CEREAL_REGISTER_POLYMORPHIC_RELATION(lbcrypto::CryptoParametersBase<lbcrypto::DCRTPoly>, lbcrypto::CryptoParametersRLWE<lbcrypto::DCRTPoly>);
 CEREAL_REGISTER_POLYMORPHIC_RELATION(lbcrypto::Serializable, lbcrypto::CryptoParametersBase<lbcrypto::DCRTPoly>);
+
+CEREAL_REGISTER_POLYMORPHIC_RELATION(lbcrypto::CryptoParametersBase<lbcrypto::DCRTModule>, lbcrypto::CryptoParametersRLWE<lbcrypto::DCRTModule>);
+CEREAL_REGISTER_POLYMORPHIC_RELATION(lbcrypto::Serializable, lbcrypto::CryptoParametersBase<lbcrypto::DCRTModule>);
 #endif
diff --git a/src/pke/include/schemebase/rlwe-cryptoparameters.h b/src/pke/include/schemebase/rlwe-cryptoparameters.h
index cb8c2c5..47fe734 100644
--- a/src/pke/include/schemebase/rlwe-cryptoparameters.h
+++ b/src/pke/include/schemebase/rlwe-cryptoparameters.h
@@ -82,6 +82,7 @@ public:
         m_statisticalSecurity   = rhs.m_statisticalSecurity;
         m_numAdversarialQueries = rhs.m_numAdversarialQueries;
         m_thresholdNumOfParties = rhs.m_thresholdNumOfParties;
+        m_moduleRank            = rhs.m_moduleRank;
     }
 
     /**
@@ -106,7 +107,7 @@ public:
                          ExecutionMode executionMode             = EXEC_EVALUATION,
                          DecryptionNoiseMode decryptionNoiseMode = FIXED_NOISE_DECRYPT, PlaintextModulus noiseScale = 1,
                          uint32_t statisticalSecurity = 30, uint32_t numAdversarialQueries = 1,
-                         uint32_t thresholdNumOfParties = 1)
+                         uint32_t thresholdNumOfParties = 1, uint32_t moduleRank = 1)
         : CryptoParametersBase<Element>(params, encodingParams) {
         m_distributionParameter = distributionParameter;
         m_assuranceMeasure      = assuranceMeasure;
@@ -123,6 +124,7 @@ public:
         m_statisticalSecurity   = statisticalSecurity;
         m_numAdversarialQueries = numAdversarialQueries;
         m_thresholdNumOfParties = thresholdNumOfParties;
+        m_moduleRank            = moduleRank;
     }
 
     /**
@@ -288,6 +290,15 @@ public:
         return m_thresholdNumOfParties;
     }
 
+    /**
+     * Gets the rank of the module
+     * 
+     * @return the rank of the module.
+     */
+    uint32_t GetModuleRank() const {
+        return m_moduleRank;
+    }
+
     // @Set Properties
 
     /**
@@ -413,6 +424,14 @@ public:
         m_thresholdNumOfParties = thresholdNumOfParties;
     }
 
+    /**
+     * Configures the rank of the module
+     * @param rank.
+     */
+    void SetModuleRank(uint32_t rank) {
+        m_moduleRank = rank;
+    }
+
     /**
    * == operator to compare to this instance of CryptoParametersRLWE object.
    *
@@ -437,7 +456,8 @@ public:
                m_floodingDistributionParameter == el->GetFloodingDistributionParameter() &&
                m_statisticalSecurity == el->GetStatisticalSecurity() &&
                m_numAdversarialQueries == el->GetNumAdversarialQueries() &&
-               m_thresholdNumOfParties == el->GetThresholdNumOfParties();
+               m_thresholdNumOfParties == el->GetThresholdNumOfParties() &&
+               m_moduleRank == el->GetModuleRank();
     }
 
     void PrintParameters(std::ostream& os) const {
@@ -540,6 +560,8 @@ protected:
     double m_numAdversarialQueries = 1;
 
     usint m_thresholdNumOfParties = 1;
+
+    uint32_t m_moduleRank = 1;
 };
 
 }  // namespace lbcrypto
diff --git a/src/pke/include/schemerns/rns-cryptoparameters.h b/src/pke/include/schemerns/rns-cryptoparameters.h
index 0d07d7d..7eb50b8 100644
--- a/src/pke/include/schemerns/rns-cryptoparameters.h
+++ b/src/pke/include/schemerns/rns-cryptoparameters.h
@@ -47,27 +47,34 @@
  */
 namespace lbcrypto {
 
+template <typename Element>
+class CryptoParametersRNSImpl;
+
+using CryptoParametersRNS = CryptoParametersRNSImpl<DCRTPoly>;
+using CryptoParametersMod = CryptoParametersRNSImpl<DCRTModule>;
+
 /**
  * @brief main implementation class to capture essential cryptoparameters of
  * any LBC system.
- * As CryptoParametersRNS is not an abstract class and we don't want to
+ * As CryptoParametersRNSImpl is not an abstract class and we don't want to
  * instantiate, then we make all its constructors and the destructor protected
  * @tparam Element a ring element.
  */
-class CryptoParametersRNS : public CryptoParametersRLWE<DCRTPoly> {
-    using ParmType = typename DCRTPoly::Params;
+template <typename Element>
+class CryptoParametersRNSImpl : public CryptoParametersRLWE<Element> {
+    using ParmType = typename Element::Params;
 
 protected:
-    CryptoParametersRNS()
-        : CryptoParametersRLWE<DCRTPoly>(),
+    CryptoParametersRNSImpl()
+        : CryptoParametersRLWE<Element>(),
           m_ksTechnique(BV),
           m_scalTechnique(FIXEDMANUAL),
           m_encTechnique(STANDARD),
           m_multTechnique(HPS),
           m_MPIntBootCiphertextCompressionLevel(SLACK) {}
 
-    CryptoParametersRNS(const CryptoParametersRNS& rhs)
-        : CryptoParametersRLWE<DCRTPoly>(rhs),
+    CryptoParametersRNSImpl(const CryptoParametersRNSImpl<Element>& rhs)
+        : CryptoParametersRLWE<Element>(rhs),
           m_ksTechnique(rhs.m_ksTechnique),
           m_scalTechnique(rhs.m_scalTechnique),
           m_encTechnique(rhs.m_encTechnique),
@@ -98,7 +105,7 @@ protected:
    * @param scalTech scaling method
    * @param mPIntBootCiphertextCompressionLevel compression level
    */
-    CryptoParametersRNS(std::shared_ptr<ParmType> params, const PlaintextModulus& plaintextModulus,
+    CryptoParametersRNSImpl(std::shared_ptr<ParmType> params, const PlaintextModulus& plaintextModulus,
                         float distributionParameter, float assuranceMeasure, SecurityLevel securityLevel,
                         usint digitSize, SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2,
                         KeySwitchTechnique ksTech = BV, ScalingTechnique scalTech = FIXEDMANUAL,
@@ -107,7 +114,7 @@ protected:
                         ExecutionMode executionMode                           = EXEC_EVALUATION,
                         DecryptionNoiseMode decryptionNoiseMode               = FIXED_NOISE_DECRYPT,
                         COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK)
-        : CryptoParametersRLWE<DCRTPoly>(
+        : CryptoParametersRLWE<Element>(
               std::move(params), EncodingParams(std::make_shared<EncodingParamsImpl>(plaintextModulus)),
               distributionParameter, assuranceMeasure, securityLevel, digitSize, maxRelinSkDeg, secretKeyDist, INDCPA,
               multipartyMode, executionMode, decryptionNoiseMode) {
@@ -118,7 +125,7 @@ protected:
         m_MPIntBootCiphertextCompressionLevel = mPIntBootCiphertextCompressionLevel;
     }
 
-    CryptoParametersRNS(std::shared_ptr<ParmType> params, EncodingParams encodingParams, float distributionParameter,
+    CryptoParametersRNSImpl(std::shared_ptr<ParmType> params, EncodingParams encodingParams, float distributionParameter,
                         float assuranceMeasure, SecurityLevel securityLevel, usint digitSize,
                         SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2, KeySwitchTechnique ksTech = BV,
                         ScalingTechnique scalTech = FIXEDMANUAL, EncryptionTechnique encTech = STANDARD,
@@ -128,11 +135,12 @@ protected:
                         DecryptionNoiseMode decryptionNoiseMode = FIXED_NOISE_DECRYPT, PlaintextModulus noiseScale = 1,
                         uint32_t statisticalSecurity = 30, uint32_t numAdversarialQueries = 1,
                         uint32_t thresholdNumOfParties                        = 1,
-                        COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK)
-        : CryptoParametersRLWE<DCRTPoly>(std::move(params), std::move(encodingParams), distributionParameter,
+                        COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK,
+                        uint32_t moduleRank = 1)
+        : CryptoParametersRLWE<Element>(std::move(params), std::move(encodingParams), distributionParameter,
                                          assuranceMeasure, securityLevel, digitSize, maxRelinSkDeg, secretKeyDist,
                                          PREMode, multipartyMode, executionMode, decryptionNoiseMode, noiseScale,
-                                         statisticalSecurity, numAdversarialQueries, thresholdNumOfParties) {
+                                         statisticalSecurity, numAdversarialQueries, thresholdNumOfParties, moduleRank) {
         m_ksTechnique                         = ksTech;
         m_scalTechnique                       = scalTech;
         m_encTechnique                        = encTech;
@@ -140,14 +148,14 @@ protected:
         m_MPIntBootCiphertextCompressionLevel = mPIntBootCiphertextCompressionLevel;
     }
 
-    virtual ~CryptoParametersRNS() {}
+    virtual ~CryptoParametersRNSImpl() {}
 
 public:
     /**
    * Computes all tables needed for decryption, homomorphic multiplication and key switching.
    * Even though this is a pure virtual function and must be overriden in all derived classes,
    * PrecomputeCRTTables() has its own implementation in the source file. It should be called from
-   * derived classes' PrecomputeCRTTables() only and must not be called from CryptoParametersRNS::load().
+   * derived classes' PrecomputeCRTTables() only and must not be called from CryptoParametersRNSImpl::load().
    * @param ksTech the technique to use for key switching (e.g., BV or GHS).
    * @param scalTech the technique to use for scaling (e.g., FLEXIBLEAUTO or FIXEDMANUAL).
    */
@@ -188,21 +196,21 @@ public:
    *
    * @param &rhs CryptoParameters to check equality against.
    */
-    bool operator==(const CryptoParametersBase<DCRTPoly>& rhs) const override {
-        const auto* el = dynamic_cast<const CryptoParametersRNS*>(&rhs);
+    bool operator==(const CryptoParametersBase<Element>& rhs) const override {
+        const auto* el = dynamic_cast<const CryptoParametersRNSImpl<Element>*>(&rhs);
 
         if (el == nullptr)
             return false;
 
-        return CryptoParametersBase<DCRTPoly>::operator==(rhs) && m_scalTechnique == el->GetScalingTechnique() &&
+        return CryptoParametersRLWE<Element>::operator==(rhs) && m_scalTechnique == el->GetScalingTechnique() &&
                m_ksTechnique == el->GetKeySwitchTechnique() && m_multTechnique == el->GetMultiplicationTechnique() &&
                m_encTechnique == el->GetEncryptionTechnique() && m_numPartQ == el->GetNumPartQ() &&
-               m_auxBits == el->GetAuxBits() && m_extraBits == el->GetExtraBits() && m_PREMode == el->GetPREMode() &&
-               m_multipartyMode == el->GetMultipartyMode() && m_executionMode == el->GetExecutionMode();
+               m_auxBits == el->GetAuxBits() && m_extraBits == el->GetExtraBits() && this->m_PREMode == el->GetPREMode() &&
+               this->m_multipartyMode == el->GetMultipartyMode() && this->m_executionMode == el->GetExecutionMode();
     }
 
     void PrintParameters(std::ostream& os) const override {
-        CryptoParametersBase<DCRTPoly>::PrintParameters(os);
+        CryptoParametersBase<Element>::PrintParameters(os);
     }
 
     /////////////////////////////////////
@@ -254,11 +262,11 @@ public:
     }
 
     const std::shared_ptr<ILDCRTParams<BigInteger>> GetParamsPK() const override {
-        if ((m_ksTechnique == HYBRID) && (m_PREMode != NOT_SET))
+        if ((m_ksTechnique == HYBRID) && (this->m_PREMode != NOT_SET))
             return m_paramsQP;
         if ((m_encTechnique == EXTENDED) && (m_paramsQr != nullptr))
             return m_paramsQr;
-        return m_params;
+        return this->m_params;
     }
 
     /////////////////////////////////////
@@ -1782,7 +1790,7 @@ public:
 
     template <class Archive>
     void save(Archive& ar, std::uint32_t const version) const {
-        ar(cereal::base_class<CryptoParametersRLWE<DCRTPoly>>(this));
+        ar(cereal::base_class<CryptoParametersRLWE<Element>>(this));
         ar(cereal::make_nvp("ks", m_ksTechnique));
         ar(cereal::make_nvp("rs", m_scalTechnique));
         ar(cereal::make_nvp("encs", m_encTechnique));
@@ -1800,7 +1808,7 @@ public:
                                " is from a later version of the library");
             OPENFHE_THROW(errMsg);
         }
-        ar(cereal::base_class<CryptoParametersRLWE<DCRTPoly>>(this));
+        ar(cereal::base_class<CryptoParametersRLWE<Element>>(this));
         ar(cereal::make_nvp("ks", m_ksTechnique));
         ar(cereal::make_nvp("rs", m_scalTechnique));
         ar(cereal::make_nvp("encs", m_encTechnique));
diff --git a/src/pke/lib/ciphertext-impl.cpp b/src/pke/lib/ciphertext-impl.cpp
index e2ec739..0148fcf 100644
--- a/src/pke/lib/ciphertext-impl.cpp
+++ b/src/pke/lib/ciphertext-impl.cpp
@@ -36,5 +36,6 @@ namespace lbcrypto {
 template class CiphertextImpl<Poly>;
 template class CiphertextImpl<NativePoly>;
 template class CiphertextImpl<DCRTPoly>;
+template class CiphertextImpl<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/cryptocontext.cpp b/src/pke/lib/cryptocontext.cpp
index 2d22aff..5a45c3c 100644
--- a/src/pke/lib/cryptocontext.cpp
+++ b/src/pke/lib/cryptocontext.cpp
@@ -79,6 +79,25 @@ void CryptoContextImpl<Element>::EvalMultKeyGen(const PrivateKey<Element> key) {
     }
 }
 
+template <typename Element>
+void CryptoContextImpl<Element>::EvalMultModKeyGen(const PrivateKey<Element> key) {
+    ValidateKey(key);
+
+    if (CryptoContextImpl<Element>::s_evalMultKeyMap.find(key->GetKeyTag()) ==
+        CryptoContextImpl<Element>::s_evalMultKeyMap.end()) {
+        // the key is not found in the map, so the key has to be generated
+        const std::vector<EvalKey<Element>>& evalKeys                  = GetScheme()->EvalMultModKeyGen(key);
+        CryptoContextImpl<Element>::s_evalMultKeyMap[key->GetKeyTag()] = evalKeys;
+    }
+}
+
+template <typename Element>
+EvalKey<Element> CryptoContextImpl<Element>::EvalRankRedKeyGen(const PrivateKey<Element> key, PrivateKey<Element>& reducedKey, usint newRank) {
+    ValidateKey(key);
+
+    return GetScheme()->EvalRankRedKeyGen(key, reducedKey, newRank);
+}
+
 template <typename Element>
 void CryptoContextImpl<Element>::EvalMultKeysGen(const PrivateKey<Element> key) {
     ValidateKey(key);
@@ -492,7 +511,7 @@ DecryptResult CryptoContextImpl<Element>::Decrypt(ConstCiphertext<Element> ciphe
         decryptedCKKS->SetScalingFactor(ciphertext->GetScalingFactor());
         decryptedCKKS->SetSlots(ciphertext->GetSlots());
 
-        const auto cryptoParamsCKKS = std::dynamic_pointer_cast<CryptoParametersRNS>(this->GetCryptoParameters());
+        const auto cryptoParamsCKKS = std::dynamic_pointer_cast<CryptoParametersRNSImpl<Element>>(this->GetCryptoParameters());
 
         decryptedCKKS->Decode(ciphertext->GetNoiseScaleDeg(), ciphertext->GetScalingFactor(),
                               cryptoParamsCKKS->GetScalingTechnique(), cryptoParamsCKKS->GetExecutionMode());
@@ -875,5 +894,6 @@ void CryptoContextImpl<DCRTPoly>::RecoverSharedKey(PrivateKey<DCRTPoly>& sk,
 }
 
 template class CryptoContextImpl<DCRTPoly>;
+template class CryptoContextImpl<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/cryptocontextfactory.cpp b/src/pke/lib/cryptocontextfactory.cpp
index 5e1cdb5..e8fddef 100644
--- a/src/pke/lib/cryptocontextfactory.cpp
+++ b/src/pke/lib/cryptocontextfactory.cpp
@@ -38,6 +38,9 @@ namespace lbcrypto {
 template <>
 std::vector<CryptoContext<DCRTPoly>> CryptoContextFactory<DCRTPoly>::AllContexts = {};
 
+template <>
+std::vector<CryptoContext<DCRTModule>> CryptoContextFactory<DCRTModule>::AllContexts = {};
+
 template <typename Element>
 CryptoContext<Element> CryptoContextFactory<Element>::FindContext(std::shared_ptr<CryptoParametersBase<Element>> params,
                                                                   std::shared_ptr<SchemeBase<Element>> scheme) {
@@ -89,5 +92,6 @@ CryptoContext<Element> CryptoContextFactory<Element>::GetFullContextByDeserializ
 namespace lbcrypto {
 
 template class CryptoContextFactory<DCRTPoly>;
+template class CryptoContextFactory<DCRTModule>;
 
-}
+}  // namespace lbcrypto
diff --git a/src/pke/lib/cryptoobject-impl.cpp b/src/pke/lib/cryptoobject-impl.cpp
index e6ff57d..cd130c2 100644
--- a/src/pke/lib/cryptoobject-impl.cpp
+++ b/src/pke/lib/cryptoobject-impl.cpp
@@ -45,5 +45,6 @@ const EncodingParams CryptoObject<Element>::GetEncodingParameters() const {
 }
 
 template class CryptoObject<DCRTPoly>;
+template class CryptoObject<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/key/evalkey.cpp b/src/pke/lib/key/evalkey.cpp
index c37c6eb..7707383 100644
--- a/src/pke/lib/key/evalkey.cpp
+++ b/src/pke/lib/key/evalkey.cpp
@@ -34,4 +34,5 @@
 // the code below is from evalkey-impl.cpp
 namespace lbcrypto {
 template class EvalKeyImpl<DCRTPoly>;
+template class EvalKeyImpl<DCRTModule>;
 }  // namespace lbcrypto
diff --git a/src/pke/lib/key/evalkeyrelin.cpp b/src/pke/lib/key/evalkeyrelin.cpp
index a47e843..ad2cbd1 100644
--- a/src/pke/lib/key/evalkeyrelin.cpp
+++ b/src/pke/lib/key/evalkeyrelin.cpp
@@ -34,4 +34,5 @@
 // the code below is from evalkeyrelin-impl.cpp
 namespace lbcrypto {
 template class EvalKeyRelinImpl<DCRTPoly>;
+template class EvalKeyRelinImpl<DCRTModule>;
 }  // namespace lbcrypto
diff --git a/src/pke/lib/key/privatekey.cpp b/src/pke/lib/key/privatekey.cpp
index c492846..f09fafd 100644
--- a/src/pke/lib/key/privatekey.cpp
+++ b/src/pke/lib/key/privatekey.cpp
@@ -34,4 +34,5 @@
 // the code below is from privatekey-impl.cpp
 namespace lbcrypto {
 template class PrivateKeyImpl<DCRTPoly>;
+template class PrivateKeyImpl<DCRTModule>;
 }  // namespace lbcrypto
diff --git a/src/pke/lib/key/publickey.cpp b/src/pke/lib/key/publickey.cpp
index 36749ce..3cc9981 100644
--- a/src/pke/lib/key/publickey.cpp
+++ b/src/pke/lib/key/publickey.cpp
@@ -34,4 +34,5 @@
 // the code below is from publickey-impl.cpp
 namespace lbcrypto {
 template class PublicKeyImpl<DCRTPoly>;
+template class PublicKeyImpl<DCRTModule>;
 }  // namespace lbcrypto
diff --git a/src/pke/lib/keyswitch/keyswitch-base.cpp b/src/pke/lib/keyswitch/keyswitch-base.cpp
index 1dc0b34..1800470 100644
--- a/src/pke/lib/keyswitch/keyswitch-base.cpp
+++ b/src/pke/lib/keyswitch/keyswitch-base.cpp
@@ -50,5 +50,6 @@ Ciphertext<Element> KeySwitchBase<Element>::KeySwitch(ConstCiphertext<Element> c
 }
 
 template class KeySwitchBase<DCRTPoly>;
+template class KeySwitchBase<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/keyswitch/keyswitch-mod.cpp b/src/pke/lib/keyswitch/keyswitch-mod.cpp
new file mode 100644
index 0000000..1746f3b
--- /dev/null
+++ b/src/pke/lib/keyswitch/keyswitch-mod.cpp
@@ -0,0 +1,348 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/**
+ * Hybrid key switching implementation. See
+ * Appendix of https://eprint.iacr.org/2021/204 for details.
+ */
+#define PROFILE
+
+#include "keyswitch/keyswitch-mod.h"
+
+#include "key/privatekey.h"
+#include "key/publickey.h"
+#include "key/evalkeyrelin.h"
+#include "scheme/ckksmod/ckksmod-cryptoparameters.h"
+#include "ciphertext.h"
+
+namespace lbcrypto {
+
+EvalKey<DCRTModule> KeySwitchMod::KeySwitchGenInternal(const PrivateKey<DCRTModule> oldKey,
+                                                       const PrivateKey<DCRTModule> newKey) const {
+    return KeySwitchMod::KeySwitchGenInternal(oldKey, newKey, nullptr);
+}
+
+EvalKey<DCRTModule> KeySwitchMod::KeySwitchGenInternal(const PrivateKey<DCRTModule> oldKey,
+                                                       const PrivateKey<DCRTModule> newKey,
+                                                       const EvalKey<DCRTModule> ekPrev) const {
+    EvalKeyRelin<DCRTModule> ek(std::make_shared<EvalKeyRelinImpl<DCRTModule>>(newKey->GetCryptoContext()));
+
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(newKey->GetCryptoParameters());
+
+    const std::shared_ptr<ParmType> paramsQ  = cryptoParams->GetElementParams();
+    const std::shared_ptr<ParmType> paramsQP = cryptoParams->GetParamsQP();
+
+    size_t sizeQ  = paramsQ->GetParams().size();
+    size_t sizeQP = paramsQP->GetParams().size();
+
+    DCRTModule sOld = oldKey->GetPrivateElement();
+    DCRTModule sNew = newKey->GetPrivateElement().Clone();
+
+    // skNew is currently in basis Q. This extends it to basis QP.
+    sNew.SetFormat(Format::COEFFICIENT);
+
+    DCRTModule sNewExt(paramsQP, Format::COEFFICIENT, true, sNew.GetModuleRows());
+
+    // The part with basis Q
+    for (size_t row = 0; row < sNew.GetModuleRows(); row++) {
+        for (size_t i = 0; i < sizeQ; i++) {
+            sNewExt.SetElementAtIndex(row, 0, i, sNew.GetElementAtIndex(row, 0, i));
+        }
+    }
+
+    // The part with basis P
+    for (size_t row = 0; row < sNew.GetModuleRows(); row++) {
+        for (size_t j = sizeQ; j < sizeQP; j++) {
+            const NativeInteger& pj    = paramsQP->GetParams()[j]->GetModulus();
+            const NativeInteger& rootj = paramsQP->GetParams()[j]->GetRootOfUnity();
+            auto sNew0                 = sNew.GetElementAtIndex(row, 0, 0);
+            sNew0.SwitchModulus(pj, rootj, 0, 0);
+            sNewExt.SetElementAtIndex(row, 0, j, std::move(sNew0));
+        }
+    }
+
+    sNewExt.SetFormat(Format::EVALUATION);
+
+    const auto ns      = cryptoParams->GetNoiseScale();
+    const DggType& dgg = cryptoParams->GetDiscreteGaussianGenerator();
+    DugType dug;
+
+    size_t numPartQ = cryptoParams->GetNumPartQ();
+
+    std::vector<DCRTModule> Av(numPartQ);
+    std::vector<DCRTModule> bv(numPartQ);
+
+    std::vector<NativeInteger> PModq = cryptoParams->GetPModq();
+    size_t numPerPartQ               = cryptoParams->GetNumPerPartQ();
+
+    for (size_t part = 0; part < numPartQ; ++part) {
+        DCRTModule A = (ekPrev == nullptr) ? DCRTModule(dug, paramsQP, Format::EVALUATION, sOld.GetModuleRows(),
+                                                        sNew.GetModuleRows()) :  // single-key HE
+                                             ekPrev->GetAVector()[part];                           // threshold HE
+        DCRTModule e(dgg, paramsQP, Format::EVALUATION, sOld.GetModuleRows());
+        DCRTModule b(paramsQP, Format::EVALUATION, true, sOld.GetModuleRows());
+
+        // starting and ending position of current part
+        size_t startPartIdx = numPerPartQ * part;
+        size_t endPartIdx   = (sizeQ > (startPartIdx + numPerPartQ)) ? (startPartIdx + numPerPartQ) : sizeQ;
+
+        for (size_t row = 0; row < sOld.GetModuleRows(); row++) {
+            for (size_t i = 0; i < sizeQP; ++i) {
+                auto Aji_sNew = A.GetElementAtIndex(row, 0, i) * sNewExt.GetElementAtIndex(0, 0, i);
+                for (size_t j = 1; j < sNewExt.GetModuleRows(); j++) {
+                    Aji_sNew += A.GetElementAtIndex(row, j, i) * sNewExt.GetElementAtIndex(j, 0, i);
+                }
+                auto ei = e.GetElementAtIndex(row, 0, i);
+
+                if (i < startPartIdx || i >= endPartIdx) {
+                    b.SetElementAtIndex(row, 0, i, -Aji_sNew + ns * ei);
+                }
+                else {
+                    // P * sOld is only applied for the current part
+                    auto sOldi = sOld.GetElementAtIndex(row, 0, i);
+                    b.SetElementAtIndex(row, 0, i, -Aji_sNew + PModq[i] * sOldi + ns * ei);
+                }
+            }
+        }
+
+        Av[part] = A;
+        bv[part] = b;
+    }
+
+    ek->SetAVector(std::move(Av));
+    ek->SetBVector(std::move(bv));
+    ek->SetKeyTag(newKey->GetKeyTag());
+    return ek;
+}
+
+void KeySwitchMod::KeySwitchInPlace(Ciphertext<DCRTModule>& ciphertext, const EvalKey<DCRTModule> ek) const {
+    std::vector<DCRTModule>& cv = ciphertext->GetElements();
+
+    std::shared_ptr<std::vector<DCRTModule>> ba =
+        (cv.size() == 2) ? KeySwitchCore(cv[1], ek) : KeySwitchCore(cv[2], ek);
+
+    cv[0].SetFormat((*ba)[0].GetFormat());
+    cv[0] += (*ba)[0];
+
+    cv[1].SetFormat((*ba)[1].GetFormat());
+    if (cv.size() > 2) {
+        cv[1] += (*ba)[1];
+    }
+    else {
+        cv[1] = (*ba)[1];
+    }
+    cv.resize(2);
+}
+
+std::shared_ptr<std::vector<DCRTModule>> KeySwitchMod::KeySwitchCore(const DCRTModule& a,
+                                                                     const EvalKey<DCRTModule> evalKey) const {
+    return EvalFastKeySwitchCore(EvalKeySwitchPrecomputeCore(a, evalKey->GetCryptoParameters()), evalKey,
+                                 a.GetParams());
+}
+
+std::shared_ptr<std::vector<DCRTModule>> KeySwitchMod::EvalKeySwitchPrecomputeCore(
+    const DCRTModule& c, std::shared_ptr<CryptoParametersBase<DCRTModule>> cryptoParamsBase) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(cryptoParamsBase);
+
+    const std::shared_ptr<ParmType> paramsQl  = c.GetParams();
+    const std::shared_ptr<ParmType> paramsP   = cryptoParams->GetParamsP();
+    const std::shared_ptr<ParmType> paramsQlP = c.GetExtendedCRTBasis(paramsP);
+
+    size_t sizeQl  = paramsQl->GetParams().size();
+    size_t sizeP   = paramsP->GetParams().size();
+    size_t sizeQlP = sizeQl + sizeP;
+
+    uint32_t alpha = cryptoParams->GetNumPerPartQ();
+    // The number of digits of the current ciphertext
+    uint32_t numPartQl = ceil((static_cast<double>(sizeQl)) / alpha);
+    if (numPartQl > cryptoParams->GetNumberOfQPartitions())
+        numPartQl = cryptoParams->GetNumberOfQPartitions();
+
+    std::vector<DCRTModule> partsCt(numPartQl);
+
+    // Digit decomposition
+    // Zero-padding and split
+    for (uint32_t part = 0; part < numPartQl; part++) {
+        if (part == numPartQl - 1) {
+            auto paramsPartQ = cryptoParams->GetParamsPartQ(part);
+
+            uint32_t sizePartQl = sizeQl - alpha * part;
+
+            std::vector<NativeInteger> moduli(sizePartQl);
+            std::vector<NativeInteger> roots(sizePartQl);
+
+            for (uint32_t i = 0; i < sizePartQl; i++) {
+                moduli[i] = paramsPartQ->GetParams()[i]->GetModulus();
+                roots[i]  = paramsPartQ->GetParams()[i]->GetRootOfUnity();
+            }
+
+            auto params = DCRTModule::Params(paramsPartQ->GetCyclotomicOrder(), moduli, roots);
+
+            partsCt[part] =
+                DCRTModule(std::make_shared<ParmType>(params), Format::EVALUATION, true, 1, c.GetModuleCols());
+        }
+        else {
+            partsCt[part] =
+                DCRTModule(cryptoParams->GetParamsPartQ(part), Format::EVALUATION, true, 1, c.GetModuleCols());
+        }
+
+        usint sizePartQl   = partsCt[part].GetNumOfElements();
+        usint startPartIdx = alpha * part;
+        for (size_t col = 0; col < c.GetModuleCols(); col++) {
+            for (uint32_t i = 0, idx = startPartIdx; i < sizePartQl; i++, idx++) {
+                partsCt[part].SetElementAtIndex(0, col, i, c.GetElementAtIndex(0, col, idx));
+            }
+        }
+    }
+
+    std::vector<DCRTModule> partsCtCompl(numPartQl);
+    std::vector<DCRTModule> partsCtExt(numPartQl);
+
+    for (uint32_t part = 0; part < numPartQl; part++) {
+        auto partCtClone = partsCt[part].Clone();
+        partCtClone.SetFormat(Format::COEFFICIENT);
+
+        uint32_t sizePartQl = partsCt[part].GetNumOfElements();
+        partsCtCompl[part]  = partCtClone.ApproxSwitchCRTBasis(
+            cryptoParams->GetParamsPartQ(part), cryptoParams->GetParamsComplPartQ(sizeQl - 1, part),
+            cryptoParams->GetPartQlHatInvModq(part, sizePartQl - 1),
+            cryptoParams->GetPartQlHatInvModqPrecon(part, sizePartQl - 1),
+            cryptoParams->GetPartQlHatModp(sizeQl - 1, part),
+            cryptoParams->GetmodComplPartqBarrettMu(sizeQl - 1, part));
+
+        partsCtCompl[part].SetFormat(Format::EVALUATION);
+
+        partsCtExt[part] = DCRTModule(paramsQlP, Format::EVALUATION, true, 1, c.GetModuleCols());
+
+        for (size_t col = 0; col < c.GetModuleCols(); col++) {
+            usint startPartIdx = alpha * part;
+            usint endPartIdx   = startPartIdx + sizePartQl;
+            for (usint i = 0; i < startPartIdx; i++) {
+                partsCtExt[part].SetElementAtIndex(0, col, i, partsCtCompl[part].GetElementAtIndex(0, col, i));
+            }
+            for (usint i = startPartIdx, idx = 0; i < endPartIdx; i++, idx++) {
+                partsCtExt[part].SetElementAtIndex(0, col, i, partsCt[part].GetElementAtIndex(0, col, idx));
+            }
+            for (usint i = endPartIdx; i < sizeQlP; ++i) {
+                partsCtExt[part].SetElementAtIndex(0, col, i,
+                                                   partsCtCompl[part].GetElementAtIndex(0, col, i - sizePartQl));
+            }
+        }
+    }
+
+    return std::make_shared<std::vector<DCRTModule>>(std::move(partsCtExt));
+}
+
+std::shared_ptr<std::vector<DCRTModule>> KeySwitchMod::EvalFastKeySwitchCore(
+    const std::shared_ptr<std::vector<DCRTModule>> digits, const EvalKey<DCRTModule> evalKey,
+    const std::shared_ptr<ParmType> paramsQl) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(evalKey->GetCryptoParameters());
+
+    std::shared_ptr<std::vector<DCRTModule>> cTilda = EvalFastKeySwitchCoreExt(digits, evalKey, paramsQl);
+
+    PlaintextModulus t = (cryptoParams->GetNoiseScale() == 1) ? 0 : cryptoParams->GetPlaintextModulus();
+
+    DCRTModule ct0 = (*cTilda)[0].ApproxModDown(paramsQl, cryptoParams->GetParamsP(), cryptoParams->GetPInvModq(),
+                                                cryptoParams->GetPInvModqPrecon(), cryptoParams->GetPHatInvModp(),
+                                                cryptoParams->GetPHatInvModpPrecon(), cryptoParams->GetPHatModq(),
+                                                cryptoParams->GetModqBarrettMu(), cryptoParams->GettInvModp(),
+                                                cryptoParams->GettInvModpPrecon(), t, cryptoParams->GettModqPrecon());
+
+    DCRTModule ct1 = (*cTilda)[1].ApproxModDown(paramsQl, cryptoParams->GetParamsP(), cryptoParams->GetPInvModq(),
+                                                cryptoParams->GetPInvModqPrecon(), cryptoParams->GetPHatInvModp(),
+                                                cryptoParams->GetPHatInvModpPrecon(), cryptoParams->GetPHatModq(),
+                                                cryptoParams->GetModqBarrettMu(), cryptoParams->GettInvModp(),
+                                                cryptoParams->GettInvModpPrecon(), t, cryptoParams->GettModqPrecon());
+
+    return std::make_shared<std::vector<DCRTModule>>(std::initializer_list<DCRTModule>{std::move(ct0), std::move(ct1)});
+}
+
+std::shared_ptr<std::vector<DCRTModule>> KeySwitchMod::EvalFastKeySwitchCoreExt(
+    const std::shared_ptr<std::vector<DCRTModule>> digits, const EvalKey<DCRTModule> evalKey,
+    const std::shared_ptr<ParmType> paramsQl) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(evalKey->GetCryptoParameters());
+    const std::vector<DCRTModule>& bv = evalKey->GetBVector();
+    const std::vector<DCRTModule>& Av = evalKey->GetAVector();
+
+    const std::shared_ptr<ParmType> paramsP   = cryptoParams->GetParamsP();
+    const std::shared_ptr<ParmType> paramsQlP = (*digits)[0].GetParams();
+
+    size_t sizeQl  = paramsQl->GetParams().size();
+    size_t sizeQlP = paramsQlP->GetParams().size();
+    size_t sizeQ   = cryptoParams->GetElementParams()->GetParams().size();
+
+    DCRTModule cTilda0(paramsQlP, Format::EVALUATION, true, 1);
+    DCRTModule cTilda1(paramsQlP, Format::EVALUATION, true, 1, Av[0].GetModuleCols());
+
+    for (uint32_t j = 0; j < digits->size(); j++) {
+        const DCRTModule& cj = (*digits)[j];
+        const DCRTModule& bj = bv[j];
+        const DCRTModule& Aj = Av[j];
+
+        for (size_t col = 0; col < cj.GetModuleCols(); col++) {
+            for (usint i = 0; i < sizeQl; i++) {
+                const auto& cji = cj.GetElementAtIndex(0, col, i);
+                const auto& bji = bj.GetElementAtIndex(col, 0, i);
+
+                cTilda0.SetElementAtIndex(0, 0, i, cTilda0.GetElementAtIndex(0, 0, i) + cji * bji);
+            }
+            for (usint i = sizeQl, idx = sizeQ; i < sizeQlP; i++, idx++) {
+                const auto& cji = cj.GetElementAtIndex(0, col, i);
+                const auto& bji = bj.GetElementAtIndex(col, 0, idx);
+
+                cTilda0.SetElementAtIndex(0, 0, i, cTilda0.GetElementAtIndex(0, 0, i) + cji * bji);
+            }
+        }
+        for (size_t col = 0; col < cTilda1.GetModuleCols(); col++) {
+            for (usint i = 0; i < sizeQl; i++) {
+                auto cji_Aji = cj.GetElementAtIndex(0, 0, i) * Aj.GetElementAtIndex(0, col, i);
+                for (size_t k = 1; k < cj.GetModuleCols(); k++) {
+                    cji_Aji += cj.GetElementAtIndex(0, k, i) * Aj.GetElementAtIndex(k, col, i);
+                }
+
+                cTilda1.SetElementAtIndex(0, col, i, cTilda1.GetElementAtIndex(0, col, i) + cji_Aji);
+            }
+            for (usint i = sizeQl, idx = sizeQ; i < sizeQlP; i++, idx++) {
+                auto cji_Aji = cj.GetElementAtIndex(0, 0, i) * Aj.GetElementAtIndex(0, col, idx);
+                for (size_t k = 1; k < cj.GetModuleCols(); k++) {
+                    cji_Aji += cj.GetElementAtIndex(0, k, i) * Aj.GetElementAtIndex(k, col, idx);
+                }
+
+                cTilda1.SetElementAtIndex(0, col, i, cTilda1.GetElementAtIndex(0, col, i) + cji_Aji);
+            }
+        }
+    }
+
+    return std::make_shared<std::vector<DCRTModule>>(
+        std::initializer_list<DCRTModule>{std::move(cTilda0), std::move(cTilda1)});
+}
+
+}  // namespace lbcrypto
diff --git a/src/pke/lib/scheme/ckksmod/ckksmod-cryptoparameters.cpp b/src/pke/lib/scheme/ckksmod/ckksmod-cryptoparameters.cpp
new file mode 100644
index 0000000..c3dd0a7
--- /dev/null
+++ b/src/pke/lib/scheme/ckksmod/ckksmod-cryptoparameters.cpp
@@ -0,0 +1,157 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+CKKS implementation. See https://eprint.iacr.org/2020/1118 for details.
+ */
+
+#define PROFILE
+
+#include "cryptocontext.h"
+#include "scheme/ckksmod/ckksmod-cryptoparameters.h"
+
+namespace lbcrypto {
+
+// Precomputation of CRT tables encryption, decryption, and  homomorphic
+// multiplication
+void CryptoParametersCKKSMod::PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech,
+                                                  EncryptionTechnique encTech, MultiplicationTechnique multTech,
+                                                  uint32_t numPartQ, uint32_t auxBits, uint32_t extraBits) {
+    CryptoParametersMod::PrecomputeCRTTables(ksTech, scalTech, encTech, multTech, numPartQ, auxBits, extraBits);
+
+    size_t sizeQ = GetElementParams()->GetParams().size();
+
+    std::vector<NativeInteger> moduliQ(sizeQ);
+    std::vector<NativeInteger> rootsQ(sizeQ);
+
+    for (size_t i = 0; i < sizeQ; i++) {
+        moduliQ[i] = GetElementParams()->GetParams()[i]->GetModulus();
+        rootsQ[i]  = GetElementParams()->GetParams()[i]->GetRootOfUnity();
+    }
+
+    BigInteger modulusQ = GetElementParams()->GetModulus();
+    // Pre-compute values for rescaling
+    // modulusQ holds Q^(l) = \prod_{i=0}^{i=l}(q_i).
+    m_QlQlInvModqlDivqlModq.resize(sizeQ - 1);
+    m_QlQlInvModqlDivqlModqPrecon.resize(sizeQ - 1);
+    m_qlInvModq.resize(sizeQ - 1);
+    m_qlInvModqPrecon.resize(sizeQ - 1);
+    for (size_t k = 0; k < sizeQ - 1; k++) {
+        size_t l = sizeQ - (k + 1);
+        modulusQ = modulusQ / BigInteger(moduliQ[l]);
+        m_QlQlInvModqlDivqlModq[k].resize(l);
+        m_QlQlInvModqlDivqlModqPrecon[k].resize(l);
+        m_qlInvModq[k].resize(l);
+        m_qlInvModqPrecon[k].resize(l);
+        BigInteger QlInvModql = modulusQ.ModInverse(moduliQ[l]);
+        BigInteger result     = (QlInvModql * modulusQ) / BigInteger(moduliQ[l]);
+        for (usint i = 0; i < l; i++) {
+            m_QlQlInvModqlDivqlModq[k][i]       = result.Mod(moduliQ[i]).ConvertToInt();
+            m_QlQlInvModqlDivqlModqPrecon[k][i] = m_QlQlInvModqlDivqlModq[k][i].PrepModMulConst(moduliQ[i]);
+            m_qlInvModq[k][i]                   = moduliQ[l].ModInverse(moduliQ[i]);
+            m_qlInvModqPrecon[k][i]             = m_qlInvModq[k][i].PrepModMulConst(moduliQ[i]);
+        }
+    }
+
+    // Pre-compute scaling factors for each level (used in FLEXIBLE* scaling techniques)
+    if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {
+        m_scalingFactorsReal.resize(sizeQ);
+
+        if ((sizeQ == 1) && (extraBits == 0)) {
+            // mult depth = 0 and FLEXIBLEAUTO
+            // when multiplicative depth = 0, we use the scaling mod size instead of modulus size
+            // Plaintext modulus is used in EncodingParamsImpl to store the exponent p of the scaling factor
+            m_scalingFactorsReal[0] = pow(2, GetPlaintextModulus());
+        }
+        else if ((sizeQ == 2) && (extraBits > 0)) {
+            // mult depth = 0 and FLEXIBLEAUTOEXT
+            // when multiplicative depth = 0, we use the scaling mod size instead of modulus size
+            // Plaintext modulus is used in EncodingParamsImpl to store the exponent p of the scaling factor
+            m_scalingFactorsReal[0] = moduliQ[sizeQ - 1].ConvertToDouble();
+            m_scalingFactorsReal[1] = pow(2, GetPlaintextModulus());
+        }
+        else {
+            m_scalingFactorsReal[0] = moduliQ[sizeQ - 1].ConvertToDouble();
+            if (extraBits > 0)
+                m_scalingFactorsReal[1] = moduliQ[sizeQ - 2].ConvertToDouble();
+            const double lastPresetFactor = (extraBits == 0) ? m_scalingFactorsReal[0] : m_scalingFactorsReal[1];
+            // number of levels with pre-calculated factors
+            const size_t numPresetFactors = (extraBits == 0) ? 1 : 2;
+
+            for (size_t k = numPresetFactors; k < sizeQ; k++) {
+                double prevSF           = m_scalingFactorsReal[k - 1];
+                m_scalingFactorsReal[k] = prevSF * prevSF / moduliQ[sizeQ - k].ConvertToDouble();
+                double ratio            = m_scalingFactorsReal[k] / lastPresetFactor;
+                if (ratio <= 0.5 || ratio >= 2.0)
+                    OPENFHE_THROW(
+                        "FLEXIBLEAUTO cannot support this number of levels in this parameter setting. Please use FIXEDMANUAL or FIXEDAUTO instead.");
+            }
+        }
+
+        m_scalingFactorsRealBig.resize(sizeQ - 1);
+
+        if (m_scalingFactorsRealBig.size() > 0) {
+            if (extraBits == 0) {
+                m_scalingFactorsRealBig[0] = m_scalingFactorsReal[0] * m_scalingFactorsReal[0];
+            }
+            else {
+                m_scalingFactorsRealBig[0] = m_scalingFactorsReal[0] * m_scalingFactorsReal[1];
+            }
+            for (uint32_t k = 1; k < sizeQ - 1; k++) {
+                m_scalingFactorsRealBig[k] = m_scalingFactorsReal[k] * m_scalingFactorsReal[k];
+            }
+        }
+
+        // Moduli as real
+        m_dmoduliQ.resize(sizeQ);
+        for (uint32_t i = 0; i < sizeQ; ++i) {
+            m_dmoduliQ[i] = moduliQ[i].ConvertToDouble();
+        }
+    }
+    else {
+        const auto p = GetPlaintextModulus();
+        m_approxSF   = pow(2, p);
+    }
+    if (m_ksTechnique == HYBRID) {
+        const auto BarrettBase128Bit(BigInteger(1).LShiftEq(128));
+        m_modqBarrettMu.resize(sizeQ);
+        for (uint32_t i = 0; i < sizeQ; i++) {
+            m_modqBarrettMu[i] = (BarrettBase128Bit / BigInteger(moduliQ[i])).ConvertToInt<DoubleNativeInt>();
+        }
+    }
+}
+
+uint64_t CryptoParametersCKKSMod::FindAuxPrimeStep() const {
+    size_t n = GetElementParams()->GetRingDimension();
+    return static_cast<uint64_t>(2 * n);
+}
+
+}  // namespace lbcrypto
diff --git a/src/pke/lib/scheme/ckksmod/ckksmod-leveledshe.cpp b/src/pke/lib/scheme/ckksmod/ckksmod-leveledshe.cpp
new file mode 100644
index 0000000..1fbb926
--- /dev/null
+++ b/src/pke/lib/scheme/ckksmod/ckksmod-leveledshe.cpp
@@ -0,0 +1,649 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+CKKS implementation. See https://eprint.iacr.org/2020/1118 for details.
+ */
+
+#include "cryptocontext.h"
+
+#include "math/hal/basicint.h"
+
+#include "scheme/ckksmod/ckksmod-cryptoparameters.h"
+#include "scheme/ckksmod/ckksmod-leveledshe.h"
+
+#include "schemebase/base-scheme.h"
+
+namespace lbcrypto {
+
+void LeveledSHECKKSMod::EvalAddInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                       ConstCiphertext<DCRTModule> ciphertext2) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext1->GetCryptoParameters());
+
+    if (cryptoParams->GetScalingTechnique() == NORESCALE) {
+        EvalAddCoreInPlace(ciphertext1, ciphertext2);
+    }
+    else {
+        auto c2 = ciphertext2->Clone();
+        AdjustForAddOrSubInPlace(ciphertext1, c2);
+
+        EvalAddCoreInPlace(ciphertext1, c2);
+    }
+}
+
+void LeveledSHECKKSMod::EvalSubInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                       ConstCiphertext<DCRTModule> ciphertext2) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext1->GetCryptoParameters());
+
+    if (cryptoParams->GetScalingTechnique() == NORESCALE) {
+        EvalSubCoreInPlace(ciphertext1, ciphertext2);
+    }
+    else {
+        auto c2 = ciphertext2->Clone();
+        AdjustForAddOrSubInPlace(ciphertext1, c2);
+
+        EvalSubCoreInPlace(ciphertext1, c2);
+    }
+}
+
+Ciphertext<DCRTModule> LeveledSHECKKSMod::EvalMult(ConstCiphertext<DCRTModule> ciphertext1,
+                                                   ConstCiphertext<DCRTModule> ciphertext2) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext1->GetCryptoParameters());
+
+    if (cryptoParams->GetScalingTechnique() == NORESCALE) {
+        return EvalMultCore(ciphertext1, ciphertext2);
+    }
+
+    auto c1 = ciphertext1->Clone();
+    auto c2 = ciphertext2->Clone();
+    AdjustForMultInPlace(c1, c2);
+
+    return EvalMultCore(c1, c2);
+}
+
+Ciphertext<DCRTModule> LeveledSHECKKSMod::EvalMultCore(ConstCiphertext<DCRTModule> ciphertext1,
+                                                       ConstCiphertext<DCRTModule> ciphertext2) const {
+    VerifyNumOfTowers(ciphertext1, ciphertext2);
+    Ciphertext<DCRTModule> result = ciphertext1->CloneZero();
+
+    std::vector<DCRTModule> cv1        = ciphertext1->GetElements();
+    const std::vector<DCRTModule>& cv2 = ciphertext2->GetElements();
+
+    if (cv1.size() != 2 || cv2.size() != 2) {
+        OPENFHE_THROW("EvalMultCore: only possible for ciphertexts of size 2.");
+    }
+
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext1->GetCryptoParameters());
+
+    std::vector<DCRTModule> cvMult(3);
+
+    cvMult[0] = cv1[0] * cv2[0];
+    cvMult[1] = cv1[1] * cv2[0] + cv1[0] * cv2[1];
+    cvMult[2] = cv1[1].HadamardProduct(cv2[1]);
+    if (cryptoParams->GetModuleRank() > 1) {
+        cvMult.push_back(cv1[1].LowerTriangleProduct(cv2[1]) + cv2[1].LowerTriangleProduct(cv1[1]));
+    }
+
+    result->SetElements(std::move(cvMult));
+    result->SetNoiseScaleDeg(ciphertext1->GetNoiseScaleDeg() + ciphertext2->GetNoiseScaleDeg());
+    result->SetScalingFactor(ciphertext1->GetScalingFactor() * ciphertext2->GetScalingFactor());
+    const auto plainMod = ciphertext1->GetCryptoParameters()->GetPlaintextModulus();
+    result->SetScalingFactorInt(
+        ciphertext1->GetScalingFactorInt().ModMul(ciphertext2->GetScalingFactorInt(), plainMod));
+    return result;
+}
+
+void LeveledSHECKKSMod::EvalMultCoreInPlace(Ciphertext<DCRTModule>& ciphertext, double operand) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext->GetCryptoParameters());
+
+    std::vector<DCRTModule::Integer> factors = GetElementForEvalMult(ciphertext, operand);
+    std::vector<DCRTModule>& cv              = ciphertext->GetElements();
+    for (usint i = 0; i < cv.size(); ++i) {
+        cv[i] = cv[i] * factors;
+    }
+    ciphertext->SetNoiseScaleDeg(ciphertext->GetNoiseScaleDeg() + 1);
+
+    double scFactor = cryptoParams->GetScalingFactorReal(ciphertext->GetLevel());
+    ciphertext->SetScalingFactor(ciphertext->GetScalingFactor() * scFactor);
+}
+
+std::vector<EvalKey<DCRTModule>> LeveledSHECKKSMod::EvalMultModKeyGen(const PrivateKey<DCRTModule> privateKey) const {
+    const auto cc           = privateKey->GetCryptoContext();
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(cc->GetCryptoParameters());
+
+    const DCRTModule& s = privateKey->GetPrivateElement();
+
+    auto algo = cc->GetScheme();
+
+    std::vector<EvalKey<DCRTModule>> evalKeyVec;
+    evalKeyVec.reserve(2);
+
+    PrivateKey<DCRTModule> privateKeyPower = std::make_shared<PrivateKeyImpl<DCRTModule>>(cc);
+    privateKeyPower->SetPrivateElement(std::move(s.HadamardProduct(s)));
+    evalKeyVec.push_back(algo->KeySwitchGen(privateKeyPower, privateKey));
+
+    if (cryptoParams->GetModuleRank() > 1) {
+        privateKeyPower->SetPrivateElement(std::move(s.LowerTriangleProduct(s)));
+        evalKeyVec.push_back(algo->KeySwitchGen(privateKeyPower, privateKey));
+    }
+    return evalKeyVec;
+}
+
+/////////////////////////////////////
+// Mod Reduce
+/////////////////////////////////////
+
+EvalKey<DCRTModule> LeveledSHECKKSMod::EvalRankRedKeyGen(const PrivateKey<DCRTModule> privateKey,
+                                                         PrivateKey<DCRTModule>& reducedKey, usint newRank) const {
+    if (newRank < 1 || newRank >= privateKey->GetPrivateElement().GetModuleRows()) {
+        OPENFHE_THROW("Invalid new rank for EvalRankRedKeyGen: " + std::to_string(newRank));
+    }
+
+    const auto cc           = privateKey->GetCryptoContext();
+    const auto cryptoParams = privateKey->GetCryptoParameters();
+
+    const DCRTModule& s = privateKey->GetPrivateElement();
+
+    auto algo = cc->GetScheme();
+
+    DCRTModule sRem;
+    auto sRed = s.DropRows(s.GetModuleRows() - newRank, sRem);
+
+    reducedKey = std::make_shared<PrivateKeyImpl<DCRTModule>>(cc);
+    reducedKey->SetPrivateElement(std::move(sRed));
+
+    PrivateKey<DCRTModule> removedKey = std::make_shared<PrivateKeyImpl<DCRTModule>>(cc);
+    removedKey->SetPrivateElement(std::move(sRem));
+
+    return algo->KeySwitchGen(removedKey, reducedKey);
+}
+
+Ciphertext<DCRTModule> LeveledSHECKKSMod::EvalRankReduce(ConstCiphertext<DCRTModule> ciphertext,
+                                                         EvalKey<DCRTModule> reduceKey) const {
+    if (ciphertext->GetElements()[1].GetModuleCols() !=
+        reduceKey->GetAVector()[0].GetModuleRows() + reduceKey->GetAVector()[0].GetModuleCols()) {
+        OPENFHE_THROW("EvalRankRedKeyGen reduceKey does not match ciphertext rank");
+    }
+
+    Ciphertext<DCRTModule> result = ciphertext->Clone();
+
+    std::vector<DCRTModule>& cv = result->GetElements();
+    for (auto& c : cv)
+        c.SetFormat(Format::EVALUATION);
+
+    auto algo = result->GetCryptoContext()->GetScheme();
+
+    DCRTModule cRemoved;
+    auto cReduced = cv[1].DropColumns(reduceKey->GetAVector()[0].GetModuleRows(), cRemoved);
+
+    std::shared_ptr<std::vector<DCRTModule>> ab = algo->KeySwitchCore(cRemoved, reduceKey);
+    cv[0] += (*ab)[0];
+    cv[1] = cReduced + (*ab)[1];
+
+    return result;
+}
+
+void LeveledSHECKKSMod::AdjustLevelsAndDepthInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                                    Ciphertext<DCRTModule>& ciphertext2) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext1->GetCryptoParameters());
+    usint c1lvl             = ciphertext1->GetLevel();
+    usint c2lvl             = ciphertext2->GetLevel();
+    usint c1depth           = ciphertext1->GetNoiseScaleDeg();
+    usint c2depth           = ciphertext2->GetNoiseScaleDeg();
+    auto sizeQl1            = ciphertext1->GetElements()[0].GetNumOfElements();
+    auto sizeQl2            = ciphertext2->GetElements()[0].GetNumOfElements();
+
+    if (c1lvl < c2lvl) {
+        if (c1depth == 2) {
+            if (c2depth == 2) {
+                double scf1 = ciphertext1->GetScalingFactor();
+                double scf2 = ciphertext2->GetScalingFactor();
+                double scf  = cryptoParams->GetScalingFactorReal(c1lvl);
+                double q1   = cryptoParams->GetModReduceFactor(sizeQl1 - 1);
+                EvalMultCoreInPlace(ciphertext1, scf2 / scf1 * q1 / scf);
+                ModReduceInternalInPlace(ciphertext1, BASE_NUM_LEVELS_TO_DROP);
+                if (c1lvl + 1 < c2lvl) {
+                    LevelReduceInternalInPlace(ciphertext1, c2lvl - c1lvl - 1);
+                }
+                ciphertext1->SetScalingFactor(ciphertext2->GetScalingFactor());
+            }
+            else {
+                if (c1lvl + 1 == c2lvl) {
+                    ModReduceInternalInPlace(ciphertext1, BASE_NUM_LEVELS_TO_DROP);
+                }
+                else {
+                    double scf1 = ciphertext1->GetScalingFactor();
+                    double scf2 = cryptoParams->GetScalingFactorRealBig(c2lvl - 1);
+                    double scf  = cryptoParams->GetScalingFactorReal(c1lvl);
+                    double q1   = cryptoParams->GetModReduceFactor(sizeQl1 - 1);
+                    EvalMultCoreInPlace(ciphertext1, scf2 / scf1 * q1 / scf);
+                    ModReduceInternalInPlace(ciphertext1, BASE_NUM_LEVELS_TO_DROP);
+                    if (c1lvl + 2 < c2lvl) {
+                        LevelReduceInternalInPlace(ciphertext1, c2lvl - c1lvl - 2);
+                    }
+                    ModReduceInternalInPlace(ciphertext1, BASE_NUM_LEVELS_TO_DROP);
+                    ciphertext1->SetScalingFactor(ciphertext2->GetScalingFactor());
+                }
+            }
+        }
+        else {
+            if (c2depth == 2) {
+                double scf1 = ciphertext1->GetScalingFactor();
+                double scf2 = ciphertext2->GetScalingFactor();
+                double scf  = cryptoParams->GetScalingFactorReal(c1lvl);
+                EvalMultCoreInPlace(ciphertext1, scf2 / scf1 / scf);
+                LevelReduceInternalInPlace(ciphertext1, c2lvl - c1lvl);
+                ciphertext1->SetScalingFactor(scf2);
+            }
+            else {
+                double scf1 = ciphertext1->GetScalingFactor();
+                double scf2 = cryptoParams->GetScalingFactorRealBig(c2lvl - 1);
+                double scf  = cryptoParams->GetScalingFactorReal(c1lvl);
+                EvalMultCoreInPlace(ciphertext1, scf2 / scf1 / scf);
+                if (c1lvl + 1 < c2lvl) {
+                    LevelReduceInternalInPlace(ciphertext1, c2lvl - c1lvl - 1);
+                }
+                ModReduceInternalInPlace(ciphertext1, BASE_NUM_LEVELS_TO_DROP);
+                ciphertext1->SetScalingFactor(ciphertext2->GetScalingFactor());
+            }
+        }
+    }
+    else if (c1lvl > c2lvl) {
+        if (c2depth == 2) {
+            if (c1depth == 2) {
+                double scf2 = ciphertext2->GetScalingFactor();
+                double scf1 = ciphertext1->GetScalingFactor();
+                double scf  = cryptoParams->GetScalingFactorReal(c2lvl);
+                double q2   = cryptoParams->GetModReduceFactor(sizeQl2 - 1);
+                EvalMultCoreInPlace(ciphertext2, scf1 / scf2 * q2 / scf);
+                ModReduceInternalInPlace(ciphertext2, BASE_NUM_LEVELS_TO_DROP);
+                if (c2lvl + 1 < c1lvl) {
+                    LevelReduceInternalInPlace(ciphertext2, c1lvl - c2lvl - 1);
+                }
+                ciphertext2->SetScalingFactor(ciphertext1->GetScalingFactor());
+            }
+            else {
+                if (c2lvl + 1 == c1lvl) {
+                    ModReduceInternalInPlace(ciphertext2, BASE_NUM_LEVELS_TO_DROP);
+                }
+                else {
+                    double scf2 = ciphertext2->GetScalingFactor();
+                    double scf1 = cryptoParams->GetScalingFactorRealBig(c1lvl - 1);
+                    double scf  = cryptoParams->GetScalingFactorReal(c2lvl);
+                    double q2   = cryptoParams->GetModReduceFactor(sizeQl2 - 1);
+                    EvalMultCoreInPlace(ciphertext2, scf1 / scf2 * q2 / scf);
+                    ModReduceInternalInPlace(ciphertext2, BASE_NUM_LEVELS_TO_DROP);
+                    if (c2lvl + 2 < c1lvl) {
+                        LevelReduceInternalInPlace(ciphertext2, c1lvl - c2lvl - 2);
+                    }
+                    ModReduceInternalInPlace(ciphertext2, BASE_NUM_LEVELS_TO_DROP);
+                    ciphertext2->SetScalingFactor(ciphertext1->GetScalingFactor());
+                }
+            }
+        }
+        else {
+            if (c1depth == 2) {
+                double scf2 = ciphertext2->GetScalingFactor();
+                double scf1 = ciphertext1->GetScalingFactor();
+                double scf  = cryptoParams->GetScalingFactorReal(c2lvl);
+                EvalMultCoreInPlace(ciphertext2, scf1 / scf2 / scf);
+                LevelReduceInternalInPlace(ciphertext2, c1lvl - c2lvl);
+                ciphertext2->SetScalingFactor(scf1);
+            }
+            else {
+                double scf2 = ciphertext2->GetScalingFactor();
+                double scf1 = cryptoParams->GetScalingFactorRealBig(c1lvl - 1);
+                double scf  = cryptoParams->GetScalingFactorReal(c2lvl);
+                EvalMultCoreInPlace(ciphertext2, scf1 / scf2 / scf);
+                if (c2lvl + 1 < c1lvl) {
+                    LevelReduceInternalInPlace(ciphertext2, c1lvl - c2lvl - 1);
+                }
+                ModReduceInternalInPlace(ciphertext2, BASE_NUM_LEVELS_TO_DROP);
+                ciphertext2->SetScalingFactor(ciphertext1->GetScalingFactor());
+            }
+        }
+    }
+    else {
+        if (c1depth < c2depth) {
+            EvalMultCoreInPlace(ciphertext1, 1.0);
+        }
+        else if (c2depth < c1depth) {
+            EvalMultCoreInPlace(ciphertext2, 1.0);
+        }
+    }
+}
+
+void LeveledSHECKKSMod::AdjustLevelsAndDepthToOneInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                                         Ciphertext<DCRTModule>& ciphertext2) const {
+    AdjustLevelsAndDepthInPlace(ciphertext1, ciphertext2);
+
+    if (ciphertext1->GetNoiseScaleDeg() == 2) {
+        ModReduceInternalInPlace(ciphertext1, BASE_NUM_LEVELS_TO_DROP);
+        ModReduceInternalInPlace(ciphertext2, BASE_NUM_LEVELS_TO_DROP);
+    }
+}
+
+Ciphertext<DCRTModule> LeveledSHECKKSMod::ModReduce(ConstCiphertext<DCRTModule> ciphertext, size_t levels) const {
+    Ciphertext<DCRTModule> result = ciphertext->Clone();
+    ModReduceInPlace(result, levels);
+    return result;
+}
+
+void LeveledSHECKKSMod::ModReduceInPlace(Ciphertext<DCRTModule>& ciphertext, size_t levels) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext->GetCryptoParameters());
+
+    if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+        ModReduceInternalInPlace(ciphertext, levels);
+    }
+}
+
+void LeveledSHECKKSMod::ModReduceInternalInPlace(Ciphertext<DCRTModule>& ciphertext, size_t levels) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext->GetCryptoParameters());
+
+    std::vector<DCRTModule>& cv = ciphertext->GetElements();
+
+    size_t sizeQ  = cryptoParams->GetElementParams()->GetParams().size();
+    size_t sizeQl = cv[0].GetNumOfElements();
+    size_t diffQl = sizeQ - sizeQl;
+
+    for (size_t l = 0; l < levels; ++l) {
+        for (size_t i = 0; i < cv.size(); ++i) {
+            cv[i].DropLastElementAndScale(cryptoParams->GetQlQlInvModqlDivqlModq(diffQl + l),
+                                          cryptoParams->GetqlInvModq(diffQl + l));
+        }
+    }
+
+    ciphertext->SetNoiseScaleDeg(ciphertext->GetNoiseScaleDeg() - levels);
+    ciphertext->SetLevel(ciphertext->GetLevel() + levels);
+
+    for (usint i = 0; i < levels; ++i) {
+        double modReduceFactor = cryptoParams->GetModReduceFactor(sizeQl - 1 - i);
+        ciphertext->SetScalingFactor(ciphertext->GetScalingFactor() / modReduceFactor);
+    }
+}
+
+void LeveledSHECKKSMod::LevelReduceInternalInPlace(Ciphertext<DCRTModule>& ciphertext, size_t levels) const {
+    std::vector<DCRTModule>& elements = ciphertext->GetElements();
+    for (auto& element : elements) {
+        element.DropLastElements(levels);
+    }
+    ciphertext->SetLevel(ciphertext->GetLevel() + levels);
+}
+
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+std::vector<DCRTModule::Integer> LeveledSHECKKSMod::GetElementForEvalMult(ConstCiphertext<DCRTModule> ciphertext,
+                                                                          double operand) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext->GetCryptoParameters());
+
+    uint32_t precision = 52;
+    double powP        = std::pow(2, precision);
+
+    // the idea is to break down real numbers
+    // expressed as input_mantissa * 2^input_exponent
+    // into (input_mantissa * 2^52) * 2^(p - 52 + input_exponent)
+    // to preserve 52-bit precision of doubles
+    // when converting to 128-bit numbers
+    int32_t n1         = 0;
+    int64_t scaled64   = std::llround(static_cast<double>(std::frexp(operand, &n1)) * powP);
+    int32_t pCurrent   = cryptoParams->GetPlaintextModulus() - precision;
+    int32_t pRemaining = pCurrent + n1;
+    int128_t scaled128 = 0;
+
+    if (pRemaining < 0) {
+        scaled128 = scaled64 >> (-pRemaining);
+    }
+    else {
+        int128_t ppRemaining = ((int128_t)1) << pRemaining;
+        scaled128            = ppRemaining * scaled64;
+    }
+
+    const std::vector<DCRTModule>& cv = ciphertext->GetElements();
+    uint32_t numTowers                = cv[0].GetNumOfElements();
+    std::vector<DCRTModule::Integer> factors(numTowers);
+
+    for (usint i = 0; i < numTowers; i++) {
+        DCRTModule::Integer modulus = cv[0].GetElementAtIndex(0, 0, i).GetModulus();
+
+        if (scaled128 < 0) {
+            DCRTModule::Integer reducedUnsigned = static_cast<BasicInteger>(-scaled128);
+            reducedUnsigned.ModEq(modulus);
+            factors[i] = modulus - reducedUnsigned;
+        }
+        else {
+            DCRTModule::Integer reducedUnsigned = static_cast<BasicInteger>(scaled128);
+            reducedUnsigned.ModEq(modulus);
+            factors[i] = reducedUnsigned;
+        }
+    }
+    return factors;
+}
+#else  // NATIVEINT == 64
+std::vector<DCRTModule::Integer> LeveledSHECKKSMod::GetElementForEvalMult(ConstCiphertext<DCRTModule> ciphertext,
+                                                                          double operand) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext->GetCryptoParameters());
+
+    const std::vector<DCRTModule>& cv = ciphertext->GetElements();
+    uint32_t numTowers                = cv[0].GetNumOfElements();
+    std::vector<DCRTModule::Integer> moduli(numTowers);
+    for (usint i = 0; i < numTowers; i++) {
+        moduli[i] = cv[0].GetElementAtIndex(0, 0, i).GetModulus();
+    }
+
+    double scFactor = cryptoParams->GetScalingFactorReal(ciphertext->GetLevel());
+
+    #if defined(HAVE_INT128)
+    typedef int128_t DoubleInteger;
+    int32_t MAX_BITS_IN_WORD_LOCAL = 125;
+    #else
+    typedef int64_t DoubleInteger;
+    int32_t MAX_BITS_IN_WORD_LOCAL = LargeScalingFactorConstants::MAX_BITS_IN_WORD;
+    #endif
+
+    // Compute approxFactor, a value to scale down by, in case the value exceeds a 64-bit integer.
+
+    // the logic below was added as the code crashes when linked with clang++ in the Debug mode and
+    // with the following flags and res is ZERO:
+    // -O2
+    // -g
+    // -fsanitize-trap=all
+    // -fsanitize=alignment,return,returns-nonnull-attribute,vla-bound,unreachable,float-cast-overflow
+    // -fsanitize=null
+    // -gz=zlib
+    // -fno-asynchronous-unwind-tables
+    // -fno-optimize-sibling-calls
+    // -fsplit-dwarf-inlining
+    // -gsimple-template-names
+    // -gsplit-dwarf
+    int32_t logApprox = 0;
+    const double res  = std::fabs(operand * scFactor);
+    if (res > 0) {
+        int32_t logSF    = static_cast<int32_t>(std::ceil(std::log2(res)));
+        int32_t logValid = (logSF <= MAX_BITS_IN_WORD_LOCAL) ? logSF : MAX_BITS_IN_WORD_LOCAL;
+        logApprox        = logSF - logValid;
+    }
+    double approxFactor = pow(2, logApprox);
+
+    DoubleInteger large     = static_cast<DoubleInteger>(operand / approxFactor * scFactor + 0.5);
+    DoubleInteger large_abs = (large < 0 ? -large : large);
+    DoubleInteger bound     = (uint64_t)1 << 63;
+
+    std::vector<DCRTModule::Integer> factors(numTowers);
+
+    if (large_abs >= bound) {
+        for (usint i = 0; i < numTowers; i++) {
+            DoubleInteger reduced = large % moduli[i].ConvertToInt();
+
+            factors[i] = (reduced < 0) ? static_cast<uint64_t>(reduced + moduli[i].ConvertToInt()) :
+                                         static_cast<uint64_t>(reduced);
+        }
+    }
+    else {
+        int64_t scConstant = static_cast<int64_t>(large);
+        for (usint i = 0; i < numTowers; i++) {
+            int64_t reduced = scConstant % static_cast<int64_t>(moduli[i].ConvertToInt());
+
+            factors[i] = (reduced < 0) ? reduced + moduli[i].ConvertToInt() : reduced;
+        }
+    }
+
+    // Scale back up by approxFactor within the CRT multiplications.
+    if (logApprox > 0) {
+        int32_t logStep             = (logApprox <= LargeScalingFactorConstants::MAX_LOG_STEP) ?
+                                          logApprox :
+                                          LargeScalingFactorConstants::MAX_LOG_STEP;
+        DCRTModule::Integer intStep = uint64_t(1) << logStep;
+        std::vector<DCRTModule::Integer> crtApprox(numTowers, intStep);
+        logApprox -= logStep;
+
+        while (logApprox > 0) {
+            int32_t logStep             = (logApprox <= LargeScalingFactorConstants::MAX_LOG_STEP) ?
+                                              logApprox :
+                                              LargeScalingFactorConstants::MAX_LOG_STEP;
+            DCRTModule::Integer intStep = uint64_t(1) << logStep;
+            std::vector<DCRTModule::Integer> crtSF(numTowers, intStep);
+            crtApprox = CKKSPackedEncoding::CRTMult(crtApprox, crtSF, moduli);
+            logApprox -= logStep;
+        }
+        factors = CKKSPackedEncoding::CRTMult(factors, crtApprox, moduli);
+    }
+
+    return factors;
+}
+
+#endif
+
+void LeveledSHECKKSMod::AdjustLevelsInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                            Ciphertext<DCRTModule>& ciphertext2) const {
+    auto sizeQl1 = ciphertext1->GetElements()[0].GetNumOfElements();
+    auto sizeQl2 = ciphertext2->GetElements()[0].GetNumOfElements();
+
+    if (sizeQl1 < sizeQl2) {
+        LevelReduceInternalInPlace(ciphertext2, sizeQl2 - sizeQl1);
+    }
+    else if (sizeQl1 > sizeQl2) {
+        LevelReduceInternalInPlace(ciphertext1, sizeQl1 - sizeQl2);
+    }
+}
+
+void LeveledSHECKKSMod::AdjustForAddOrSubInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                                 Ciphertext<DCRTModule>& ciphertext2) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext1->GetCryptoParameters());
+
+    if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+        AdjustLevelsInPlace(ciphertext1, ciphertext2);
+
+        double scFactor = cryptoParams->GetScalingFactorReal();
+
+        // supported only for CKKS
+        if (scFactor == 0.0)
+            return;
+
+        DCRTModule ptxt;
+        uint32_t ptxtDepth = 0;
+        uint32_t ctxtDepth = 0;
+        usint sizeQl       = 0;
+        uint32_t ptxtIndex = 0;
+
+        // Get moduli chain to create CRT representation of powP
+        std::vector<DCRTModule::Integer> moduli;
+
+        if (ciphertext1->NumberCiphertextElements() == 1) {
+            ptxt      = ciphertext1->GetElements()[0];
+            ptxtDepth = ciphertext1->GetNoiseScaleDeg();
+            ctxtDepth = ciphertext2->GetNoiseScaleDeg();
+            sizeQl    = ciphertext2->GetElements()[0].GetNumOfElements();
+            moduli.resize(sizeQl);
+            for (usint i = 0; i < sizeQl; i++) {
+                moduli[i] = ciphertext2->GetElements()[0].GetElementAtIndex(0, 0, i).GetModulus();
+            }
+            ptxtIndex = 1;
+        }
+        else if (ciphertext2->NumberCiphertextElements() == 1) {
+            ptxt      = ciphertext2->GetElements()[0];
+            ptxtDepth = ciphertext2->GetNoiseScaleDeg();
+            ctxtDepth = ciphertext1->GetNoiseScaleDeg();
+            sizeQl    = ciphertext1->GetElements()[0].GetNumOfElements();
+            moduli.resize(sizeQl);
+            for (usint i = 0; i < sizeQl; i++) {
+                moduli[i] = ciphertext1->GetElements()[0].GetElementAtIndex(0, 0, i).GetModulus();
+            }
+            ptxtIndex = 2;
+        }
+        else
+            return;
+
+        // Bring to same depth if not already same
+        if (ptxtDepth < ctxtDepth) {
+            // Find out how many levels to scale plaintext up.
+            size_t diffDepth = ctxtDepth - ptxtDepth;
+
+            DCRTModule::Integer intSF = static_cast<NativeInteger::Integer>(scFactor + 0.5);
+            std::vector<DCRTModule::Integer> crtSF(sizeQl, intSF);
+            auto crtPowSF = crtSF;
+            for (usint j = 0; j < diffDepth - 1; j++) {
+                crtPowSF = CKKSPackedEncoding::CRTMult(crtPowSF, crtSF, moduli);
+            }
+
+            if (ptxtIndex == 1) {
+                ciphertext1->SetElements(std::vector<DCRTModule>{ptxt.Times(crtPowSF)});
+                ciphertext1->SetNoiseScaleDeg(ctxtDepth);
+            }
+            else {
+                ciphertext2->SetElements(std::vector<DCRTModule>{ptxt.Times(crtPowSF)});
+                ciphertext2->SetNoiseScaleDeg(ctxtDepth);
+            }
+        }
+        else if (ptxtDepth > ctxtDepth) {
+            OPENFHE_THROW("plaintext cannot be encoded at a larger depth than that of the ciphertext.");
+        }
+    }
+    else if (cryptoParams->GetScalingTechnique() != NORESCALE) {
+        AdjustLevelsAndDepthInPlace(ciphertext1, ciphertext2);
+    }
+}
+
+void LeveledSHECKKSMod::AdjustForMultInPlace(Ciphertext<DCRTModule>& ciphertext1,
+                                             Ciphertext<DCRTModule>& ciphertext2) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext1->GetCryptoParameters());
+
+    if (cryptoParams->GetScalingTechnique() == FIXEDMANUAL) {
+        AdjustLevelsInPlace(ciphertext1, ciphertext2);
+    }
+    else if (cryptoParams->GetScalingTechnique() != NORESCALE) {
+        AdjustLevelsAndDepthToOneInPlace(ciphertext1, ciphertext2);
+        if (ciphertext1->GetNoiseScaleDeg() == 2) {
+            ModReduceInternalInPlace(ciphertext1, BASE_NUM_LEVELS_TO_DROP);
+            ModReduceInternalInPlace(ciphertext2, BASE_NUM_LEVELS_TO_DROP);
+        }
+    }
+}
+
+}  // namespace lbcrypto
diff --git a/src/pke/lib/scheme/ckksmod/ckksmod-parametergeneration.cpp b/src/pke/lib/scheme/ckksmod/ckksmod-parametergeneration.cpp
new file mode 100644
index 0000000..d6f87cc
--- /dev/null
+++ b/src/pke/lib/scheme/ckksmod/ckksmod-parametergeneration.cpp
@@ -0,0 +1,287 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+CKKS implementation. See https://eprint.iacr.org/2020/1118 for details.
+ */
+
+#define PROFILE
+
+#include "cryptocontext.h"
+#include "scheme/ckksmod/ckksmod-cryptoparameters.h"
+#include "scheme/ckksmod/ckksmod-parametergeneration.h"
+
+namespace lbcrypto {
+
+#if NATIVEINT == 128 && !defined(__EMSCRIPTEN__)
+const size_t AUXMODSIZE = 119;
+#else
+const size_t AUXMODSIZE = 60;
+#endif
+
+bool ParameterGenerationCKKSMod::ParamsGenCKKSMod(std::shared_ptr<CryptoParametersBase<DCRTModule>> cryptoParams,
+                                                  usint cyclOrder, usint numPrimes, usint scalingModSize,
+                                                  usint firstModSize, uint32_t numPartQ,
+                                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel,
+                                                  usint moduleRank) const {
+    // the "const" modifier for cryptoParamsCKKSMod and encodingParams below doesn't mean that the objects those 2 pointers
+    // point to are const (not changeable). it means that the pointers themselves are const only.
+    const auto cryptoParamsCKKSMod      = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(cryptoParams);
+    const EncodingParams encodingParams = cryptoParamsCKKSMod->GetEncodingParams();
+
+    KeySwitchTechnique ksTech        = cryptoParamsCKKSMod->GetKeySwitchTechnique();
+    ScalingTechnique scalTech        = cryptoParamsCKKSMod->GetScalingTechnique();
+    EncryptionTechnique encTech      = cryptoParamsCKKSMod->GetEncryptionTechnique();
+    MultiplicationTechnique multTech = cryptoParamsCKKSMod->GetMultiplicationTechnique();
+    ProxyReEncryptionMode PREMode    = cryptoParamsCKKSMod->GetPREMode();
+
+    if ((PREMode != INDCPA) && (PREMode != NOT_SET)) {
+        std::stringstream s;
+        s << "This PRE mode " << PREMode << " is not supported for CKKSRNS";
+        OPENFHE_THROW(s.str());
+    }
+
+    // TODO: Allow the user to specify this?
+    uint32_t extraModSize = (scalTech == FLEXIBLEAUTOEXT) ? DCRT_MODULUS::DEFAULT_EXTRA_MOD_SIZE : 0;
+
+    //// HE Standards compliance logic/check
+    SecurityLevel stdLevel = cryptoParamsCKKSMod->GetStdLevel();
+    uint32_t auxBits       = AUXMODSIZE;
+    uint32_t n             = cyclOrder / 2;
+    uint32_t qBound        = firstModSize + (numPrimes - 1) * scalingModSize + extraModSize;
+
+    // we add an extra bit to account for the alternating logic of selecting the RNS moduli in CKKS
+    // ignore the case when there is only one max size modulus
+    if (qBound != auxBits)
+        qBound++;
+
+    // Estimate ciphertext modulus Q*P bound (in case of HYBRID P*Q)
+    if (ksTech == HYBRID) {
+        auto hybridKSInfo = CryptoParametersRNS::EstimateLogP(numPartQ, firstModSize, scalingModSize, extraModSize,
+                                                              numPrimes, auxBits, true);
+        qBound += std::get<0>(hybridKSInfo);
+    }
+
+    // GAUSSIAN security constraint
+    DistributionType distType = (cryptoParamsCKKSMod->GetSecretKeyDist() == GAUSSIAN) ? HEStd_error : HEStd_ternary;
+    auto nRLWE                = [&](uint32_t q) -> uint32_t {
+        return StdLatticeParm::FindRingDim(distType, stdLevel, q);
+    };
+
+    // Case 1: SecurityLevel specified as HEStd_NotSet -> Do nothing
+    if (stdLevel != HEStd_NotSet) {
+        if (n == 0) {
+            // Case 2: SecurityLevel specified, but ring dimension not specified
+
+            // Choose ring dimension based on security standards
+            n         = nRLWE(qBound) / moduleRank;
+            cyclOrder = 2 * n;
+        }
+        else {  // if (n!=0)
+            // Case 3: Both SecurityLevel and ring dimension specified
+
+            // Check whether particular selection is standards-compliant
+            auto he_std_n = nRLWE(qBound) / moduleRank;
+            if (he_std_n > n) {
+                OPENFHE_THROW("The specified ring dimension (" + std::to_string(n) +
+                              ") does not comply with HE standards recommendation (" + std::to_string(he_std_n) + ").");
+            }
+        }
+    }
+    else if (n == 0) {
+        OPENFHE_THROW("Please specify the ring dimension or desired security level.");
+    }
+
+    if (encodingParams->GetBatchSize() > n / 2)
+        OPENFHE_THROW("The batch size cannot be larger than ring dimension / 2.");
+
+    if (encodingParams->GetBatchSize() & (encodingParams->GetBatchSize() - 1))
+        OPENFHE_THROW("The batch size can only be set to zero (for full packing) or a power of two.");
+    //// End HE Standards compliance logic/check
+
+    uint32_t dcrtBits = scalingModSize;
+
+    uint32_t vecSize = (extraModSize == 0) ? numPrimes : numPrimes + 1;
+    std::vector<NativeInteger> moduliQ(vecSize);
+    std::vector<NativeInteger> rootsQ(vecSize);
+
+    NativeInteger q        = FirstPrime<NativeInteger>(dcrtBits, cyclOrder);
+    moduliQ[numPrimes - 1] = q;
+    rootsQ[numPrimes - 1]  = RootOfUnity(cyclOrder, moduliQ[numPrimes - 1]);
+
+    NativeInteger maxPrime{q};
+    NativeInteger minPrime{q};
+    if (numPrimes > 1) {
+        if (scalTech != FLEXIBLEAUTO && scalTech != FLEXIBLEAUTOEXT) {
+            NativeInteger qPrev = q;
+            NativeInteger qNext = q;
+            for (size_t i = numPrimes - 2, cnt = 0; i >= 1; --i, ++cnt) {
+                if ((cnt % 2) == 0) {
+                    qPrev      = PreviousPrime(qPrev, cyclOrder);
+                    moduliQ[i] = qPrev;
+                }
+                else {
+                    qNext      = NextPrime(qNext, cyclOrder);
+                    moduliQ[i] = qNext;
+                }
+
+                if (moduliQ[i] > maxPrime)
+                    maxPrime = moduliQ[i];
+                else if (moduliQ[i] < minPrime)
+                    minPrime = moduliQ[i];
+
+                rootsQ[i] = RootOfUnity(cyclOrder, moduliQ[i]);
+            }
+        }
+        else {  // FLEXIBLEAUTO
+            /* Scaling factors in FLEXIBLEAUTO are a bit fragile,
+            * in the sense that once one scaling factor gets far enough from the
+            * original scaling factor, subsequent level scaling factors quickly
+            * diverge to either 0 or infinity. To mitigate this problem to a certain
+            * extend, we have a special prime selection process in place. The goal is
+            * to maintain the scaling factor of all levels as close to the original
+            * scale factor of level 0 as possible.
+            */
+            double sf = moduliQ[numPrimes - 1].ConvertToDouble();
+            for (size_t i = numPrimes - 2, cnt = 0; i >= 1; --i, ++cnt) {
+                sf                  = static_cast<double>(pow(sf, 2) / moduliQ[i + 1].ConvertToDouble());
+                NativeInteger sfInt = std::llround(sf);
+                NativeInteger sfRem = sfInt.Mod(cyclOrder);
+                bool hasSameMod     = true;
+                if ((cnt % 2) == 0) {
+                    NativeInteger qPrev = sfInt - NativeInteger(cyclOrder) - sfRem + NativeInteger(1);
+                    while (hasSameMod) {
+                        hasSameMod = false;
+                        qPrev      = PreviousPrime(qPrev, cyclOrder);
+                        for (size_t j = i + 1; j < numPrimes; j++) {
+                            if (qPrev == moduliQ[j]) {
+                                hasSameMod = true;
+                                break;
+                            }
+                        }
+                    }
+                    moduliQ[i] = qPrev;
+                }
+                else {
+                    NativeInteger qNext = sfInt + NativeInteger(cyclOrder) - sfRem + NativeInteger(1);
+                    while (hasSameMod) {
+                        hasSameMod = false;
+                        qNext      = NextPrime(qNext, cyclOrder);
+                        for (size_t j = i + 1; j < numPrimes; j++) {
+                            if (qNext == moduliQ[j]) {
+                                hasSameMod = true;
+                                break;
+                            }
+                        }
+                    }
+                    moduliQ[i] = qNext;
+                }
+                if (moduliQ[i] > maxPrime)
+                    maxPrime = moduliQ[i];
+                else if (moduliQ[i] < minPrime)
+                    minPrime = moduliQ[i];
+
+                rootsQ[i] = RootOfUnity(cyclOrder, moduliQ[i]);
+            }
+        }
+    }
+
+    if (firstModSize == dcrtBits) {  // this requires dcrtBits < 60
+        moduliQ[0] = NextPrime<NativeInteger>(maxPrime, cyclOrder);
+    }
+    else {
+        moduliQ[0] = LastPrime<NativeInteger>(firstModSize, cyclOrder);
+
+        // find if the value of moduliQ[0] is already in the vector starting with moduliQ[1] and
+        // if there is, then get another prime for moduliQ[0]
+        const auto pos = std::find(moduliQ.begin() + 1, moduliQ.end(), moduliQ[0]);
+        if (pos != moduliQ.end()) {
+            moduliQ[0] = NextPrime<NativeInteger>(maxPrime, cyclOrder);
+        }
+    }
+    if (moduliQ[0] > maxPrime)
+        maxPrime = moduliQ[0];
+
+    rootsQ[0] = RootOfUnity(cyclOrder, moduliQ[0]);
+
+    if (scalTech == FLEXIBLEAUTOEXT) {
+        // moduliQ[numPrimes] must still be 0, so it has to be populated now
+
+        // no need for extra checking as extraModSize is automatically chosen by the library
+        auto tempMod = FirstPrime<NativeInteger>(extraModSize - 1, cyclOrder);
+        // check if tempMod has a duplicate in the vector (exclude moduliQ[numPrimes] from this operation):
+        const auto endPos = moduliQ.end() - 1;
+        auto pos          = std::find(moduliQ.begin(), endPos, tempMod);
+        // if there is a duplicate, then we call NextPrime()
+        moduliQ[numPrimes] = (pos != endPos) ? NextPrime<NativeInteger>(maxPrime, cyclOrder) : tempMod;
+
+        rootsQ[numPrimes] = RootOfUnity(cyclOrder, moduliQ[numPrimes]);
+    }
+
+    auto paramsDCRT = std::make_shared<ILDCRTParams<BigInteger>>(cyclOrder, moduliQ, rootsQ);
+
+    cryptoParamsCKKSMod->SetElementParams(paramsDCRT);
+
+    // if no batch size was specified, we set batchSize = n/2 by default (for full packing)
+    if (encodingParams->GetBatchSize() == 0) {
+        uint32_t batchSize = n / 2;
+        EncodingParams encodingParamsNew(
+            std::make_shared<EncodingParamsImpl>(encodingParams->GetPlaintextModulus(), batchSize));
+        cryptoParamsCKKSMod->SetEncodingParams(encodingParamsNew);
+    }
+
+    cryptoParamsCKKSMod->PrecomputeCRTTables(ksTech, scalTech, encTech, multTech, numPartQ, auxBits, extraModSize);
+
+    // Validate the ring dimension found using estimated logQ(P) against actual logQ(P)
+    if (stdLevel != HEStd_NotSet) {
+        uint32_t logActualQ = 0;
+        if (ksTech == HYBRID) {
+            logActualQ = cryptoParamsCKKSMod->GetParamsQP()->GetModulus().GetMSB();
+        }
+        else {
+            logActualQ = cryptoParamsCKKSMod->GetElementParams()->GetModulus().GetMSB();
+        }
+
+        uint32_t nActual = StdLatticeParm::FindRingDim(distType, stdLevel, logActualQ) / moduleRank;
+        if (n < nActual) {
+            std::string errMsg("The ring dimension found using estimated logQ(P) [");
+            errMsg += std::to_string(n) + "] does does not meet security requirements. ";
+            errMsg += "Report this problem to OpenFHE developers and set the ring dimension manually to ";
+            errMsg += std::to_string(nActual) + ".";
+
+            OPENFHE_THROW(errMsg);
+        }
+    }
+
+    return true;
+}
+
+}  // namespace lbcrypto
diff --git a/src/pke/lib/scheme/ckksmod/ckksmod-pke.cpp b/src/pke/lib/scheme/ckksmod/ckksmod-pke.cpp
new file mode 100644
index 0000000..c0ab69c
--- /dev/null
+++ b/src/pke/lib/scheme/ckksmod/ckksmod-pke.cpp
@@ -0,0 +1,220 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+CKKS implementation. If NOISE_FLOODING_DECRYPT is set, we flood the decryption bits with noise.
+ */
+
+#define PROFILE
+
+#include "cryptocontext.h"
+#include "scheme/ckksmod/ckksmod-cryptoparameters.h"
+#include "scheme/ckksmod/ckksmod-pke.h"
+
+namespace lbcrypto {
+
+// makeSparse is not used by this scheme
+KeyPair<DCRTModule> PKECKKSMOD::KeyGenInternal(CryptoContext<DCRTModule> cc, bool makeSparse) const {
+    KeyPair<DCRTModule> keyPair(std::make_shared<PublicKeyImpl<DCRTModule>>(cc),
+                                std::make_shared<PrivateKeyImpl<DCRTModule>>(cc));
+
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(cc->GetCryptoParameters());
+
+    const std::shared_ptr<ParmType> elementParams = cryptoParams->GetElementParams();
+    const std::shared_ptr<ParmType> paramsPK      = cryptoParams->GetParamsPK();
+    if (!paramsPK) {
+        OPENFHE_THROW("PrecomputeCRTTables() must be called before using precomputed params.");
+    }
+
+    const auto ns      = cryptoParams->GetNoiseScale();
+    const DggType& dgg = cryptoParams->GetDiscreteGaussianGenerator();
+    DugType dug;
+    TugType tug;
+
+    // Private Key Generation
+
+    DCRTModule s;
+    switch (cryptoParams->GetSecretKeyDist()) {
+        case GAUSSIAN:
+            s = DCRTModule(dgg, paramsPK, Format::EVALUATION, cryptoParams->GetModuleRank());
+            break;
+        case UNIFORM_TERNARY:
+            s = DCRTModule(tug, paramsPK, Format::EVALUATION, 0, cryptoParams->GetModuleRank());
+            break;
+        case SPARSE_TERNARY:
+            // https://github.com/openfheorg/openfhe-development/issues/311
+            s = DCRTModule(tug, paramsPK, Format::EVALUATION, 192, cryptoParams->GetModuleRank());
+            break;
+        default:
+            break;
+    }
+
+    // Public Key Generation
+
+    DCRTModule A(dug, paramsPK, Format::EVALUATION, cryptoParams->GetModuleRank(), cryptoParams->GetModuleRank());
+    DCRTModule e(dgg, paramsPK, Format::EVALUATION, cryptoParams->GetModuleRank());
+    DCRTModule b(ns * e - A * s);
+
+    keyPair.secretKey->SetPrivateElement(std::move(s));
+    keyPair.publicKey->SetPublicElements(std::vector<DCRTModule>{std::move(b), std::move(A)});
+    keyPair.publicKey->SetKeyTag(keyPair.secretKey->GetKeyTag());
+
+    return keyPair;
+}
+
+Ciphertext<DCRTModule> PKECKKSMOD::Encrypt(DCRTModule plaintext, const PrivateKey<DCRTModule> privateKey) const {
+    OPENFHE_THROW("Encrypt not supported for modules");
+}
+
+Ciphertext<DCRTModule> PKECKKSMOD::Encrypt(DCRTModule plaintext, const PublicKey<DCRTModule> publicKey) const {
+    Ciphertext<DCRTModule> ciphertext(std::make_shared<CiphertextImpl<DCRTModule>>(publicKey));
+
+    const std::shared_ptr<ParmType> ptxtParams  = plaintext.GetParams();
+    std::shared_ptr<std::vector<DCRTModule>> ba = EncryptZeroCore(publicKey, ptxtParams);
+
+    plaintext.SetFormat(EVALUATION);
+
+    (*ba)[0] += plaintext;
+
+    ciphertext->SetElements({std::move((*ba)[0]), std::move((*ba)[1])});
+    ciphertext->SetNoiseScaleDeg(1);
+
+    return ciphertext;
+}
+
+std::shared_ptr<std::vector<DCRTModule>> PKECKKSMOD::EncryptZeroCore(const PrivateKey<DCRTModule> privateKey,
+                                                                     const std::shared_ptr<ParmType> params) const {
+    OPENFHE_THROW("EncryptZeroCore not supported for modules");
+}
+
+std::shared_ptr<std::vector<DCRTModule>> PKECKKSMOD::EncryptZeroCore(const PublicKey<DCRTModule> publicKey,
+                                                                     const std::shared_ptr<ParmType> params) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(publicKey->GetCryptoParameters());
+
+    const std::vector<DCRTModule>& pk = publicKey->GetPublicElements();
+    const auto ns                     = cryptoParams->GetNoiseScale();
+    const DggType& dgg                = cryptoParams->GetDiscreteGaussianGenerator();
+
+    TugType tug;
+
+    const std::shared_ptr<ParmType> elementParams = (params == nullptr) ? cryptoParams->GetElementParams() : params;
+    // TODO (dsuponit): "tug" must be assigned with TernaryUniformGenerator. Otherwise the DCRTModule constructor crashes.
+    // check other files if "tug" is properly assigned
+    // if (cryptoParams->GetSecretKeyDist() != GAUSSIAN) {
+    //    OPENFHE_THROW("TugType tug must be assigned");
+    //}
+    DCRTModule v = cryptoParams->GetSecretKeyDist() == GAUSSIAN ?
+                       DCRTModule(dgg, elementParams, Format::EVALUATION, 1, cryptoParams->GetModuleRank()) :
+                       DCRTModule(tug, elementParams, Format::EVALUATION, 0, 1, cryptoParams->GetModuleRank());
+
+    // noise generation with the discrete gaussian generator dgg
+    DCRTModule e0(dgg, elementParams, Format::EVALUATION, 1);
+    DCRTModule e1(dgg, elementParams, Format::EVALUATION, 1, cryptoParams->GetModuleRank());
+
+    uint32_t sizeQ  = pk[0].GetParams()->GetParams().size();
+    uint32_t sizeQl = elementParams->GetParams().size();
+
+    DCRTModule c0, c1;
+    if (sizeQl != sizeQ) {
+        // Clone public keys because we need to drop towers.
+        DCRTModule p0 = pk[0].Clone();
+        DCRTModule p1 = pk[1].Clone();
+
+        uint32_t diffQl = sizeQ - sizeQl;
+        p0.DropLastElements(diffQl);
+        p1.DropLastElements(diffQl);
+
+        c0 = v * p0 + ns * e0;
+        c1 = v * p1 + ns * e1;
+    }
+    else {
+        // Use public keys as they are
+        const DCRTModule& p0 = pk[0];
+        const DCRTModule& p1 = pk[1];
+
+        c0 = v * p0 + ns * e0;
+        c1 = v * p1 + ns * e1;
+    }
+
+    return std::make_shared<std::vector<DCRTModule>>(std::initializer_list<DCRTModule>({std::move(c0), std::move(c1)}));
+}
+
+DecryptResult PKECKKSMOD::Decrypt(ConstCiphertext<DCRTModule> ciphertext, const PrivateKey<DCRTModule> privateKey,
+                                  NativePoly* plaintext) const {
+    OPENFHE_THROW("Decrypt not supported for modules");
+}
+
+DecryptResult PKECKKSMOD::Decrypt(ConstCiphertext<DCRTModule> ciphertext, const PrivateKey<DCRTModule> privateKey,
+                                  Poly* plaintext) const {
+    const auto cryptoParams = std::dynamic_pointer_cast<CryptoParametersCKKSMod>(ciphertext->GetCryptoParameters());
+    const std::vector<DCRTModule>& cv = ciphertext->GetElements();
+    DCRTModule b                      = DecryptCore(cv, privateKey);
+    if (cryptoParams->GetDecryptionNoiseMode() == NOISE_FLOODING_DECRYPT &&
+        cryptoParams->GetExecutionMode() == EXEC_EVALUATION) {
+        auto dgg = cryptoParams->GetFloodingDiscreteGaussianGenerator();
+        DCRTModule noise(dgg, cv[0].GetParams(), Format::EVALUATION, cryptoParams->GetModuleRank());
+        b += noise;
+    }
+
+    b.SetFormat(Format::COEFFICIENT);
+    const size_t sizeQl = b.GetParams()->GetParams().size();
+
+    if (sizeQl == 0)
+        OPENFHE_THROW("Decryption failure: No towers left; consider increasing the depth.");
+
+    if (sizeQl == 1) {
+        *plaintext = Poly(b.GetDCRTPolyAt(0).GetElementAtIndex(0), Format::COEFFICIENT);
+    }
+    else {
+        *plaintext = b.GetDCRTPolyAt(0).CRTInterpolate();
+    }
+
+    return DecryptResult(plaintext->GetLength());
+}
+
+DCRTModule PKECKKSMOD::DecryptCore(const std::vector<DCRTModule>& cv, const PrivateKey<DCRTModule> privateKey) const {
+    if (cv.size() != 2) {
+        OPENFHE_THROW("Decryption of ciphertext with more than 2 elements is not supported");
+    }
+    DCRTModule s = privateKey->GetPrivateElement();
+
+    size_t sizeQ  = s.GetParams()->GetParams().size();
+    size_t sizeQl = cv[0].GetParams()->GetParams().size();
+
+    size_t diffQl = sizeQ - sizeQl;
+
+    auto scopy(s);
+    scopy.DropLastElements(diffQl);
+
+    return cv[0] + cv[1] * scopy;
+}
+
+}  // namespace lbcrypto
diff --git a/src/pke/lib/scheme/ckksmod/ckksmod-scheme.cpp b/src/pke/lib/scheme/ckksmod/ckksmod-scheme.cpp
new file mode 100644
index 0000000..bda7c25
--- /dev/null
+++ b/src/pke/lib/scheme/ckksmod/ckksmod-scheme.cpp
@@ -0,0 +1,84 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+CKKS implementation. See https://eprint.iacr.org/2020/1118 for details.
+ */
+
+#define PROFILE
+
+#include "scheme/ckksmod/ckksmod-scheme.h"
+#include "keyswitch/keyswitch-mod.h"
+
+namespace lbcrypto {
+
+void SchemeCKKSMod::Enable(PKESchemeFeature feature) {
+    switch (feature) {
+        case PKE:
+            if (m_PKE == nullptr)
+                m_PKE = std::make_shared<PKECKKSMOD>();
+            break;
+        case KEYSWITCH:
+            if (m_KeySwitch == nullptr)
+                m_KeySwitch = std::make_shared<KeySwitchMod>();
+            break;
+        // case PRE:
+        //     if (m_PRE == nullptr)
+        //         m_PRE = std::make_shared<PRECKKSRNS>();
+        //     break;
+        case LEVELEDSHE:
+            if (m_LeveledSHE == nullptr)
+                m_LeveledSHE = std::make_shared<LeveledSHECKKSMod>();
+            break;
+        // case MULTIPARTY:
+        //     if (m_Multiparty == nullptr)
+        //         m_Multiparty = std::make_shared<MultipartyCKKSRNS>();
+        //     break;
+        // case ADVANCEDSHE:
+        //     if (m_AdvancedSHE == nullptr)
+        //         m_AdvancedSHE = std::make_shared<AdvancedSHECKKSRNS>();
+        //     break;
+        // case FHE:
+        //     if (m_FHE == nullptr)
+        //         m_FHE = std::make_shared<FHECKKSRNS>();
+        //     break;
+        // case SCHEMESWITCH:
+        //     if (m_SchemeSwitch == nullptr)
+        //         m_SchemeSwitch = std::make_shared<SWITCHCKKSRNS>();
+        //     break;
+        default:
+            std::stringstream ss;
+            ss << feature;
+            OPENFHE_THROW(std::string("This feature [") + ss.str() + "] is not supported for CKKSMod scheme");
+    }
+}
+
+}  // namespace lbcrypto
diff --git a/src/pke/lib/scheme/gen-cryptocontext-params-impl.cpp b/src/pke/lib/scheme/gen-cryptocontext-params-impl.cpp
index 6f4d694..619ba88 100644
--- a/src/pke/lib/scheme/gen-cryptocontext-params-impl.cpp
+++ b/src/pke/lib/scheme/gen-cryptocontext-params-impl.cpp
@@ -76,12 +76,16 @@ namespace lbcrypto {
         SET_TO_SCHEME_DEFAULT(SCHEME, numAdversarialQueries);           \
         SET_TO_SCHEME_DEFAULT(SCHEME, thresholdNumOfParties);           \
         SET_TO_SCHEME_DEFAULT(SCHEME, interactiveBootCompressionLevel); \
+        SET_TO_SCHEME_DEFAULT(SCHEME, moduleRank); \
     }
 void Params::SetToDefaults(SCHEME scheme) {
     switch (scheme) {
         case CKKSRNS_SCHEME:
             SET_TO_SCHEME_DEFAULTS(CKKSRNS_SCHEME);
             break;
+        case CKKSMOD_SCHEME:
+            SET_TO_SCHEME_DEFAULTS(CKKSMOD_SCHEME);
+            break;
         case BFVRNS_SCHEME:
             SET_TO_SCHEME_DEFAULTS(BFVRNS_SCHEME);
             break;
diff --git a/src/pke/lib/scheme/scheme-id-impl.cpp b/src/pke/lib/scheme/scheme-id-impl.cpp
index 12d10ab..b15bc72 100644
--- a/src/pke/lib/scheme/scheme-id-impl.cpp
+++ b/src/pke/lib/scheme/scheme-id-impl.cpp
@@ -70,6 +70,9 @@ std::ostream& operator<<(std::ostream& os, SCHEME schemeId) {
         case CKKSRNS_SCHEME:
             os << "CKKSRNS";
             break;
+        case CKKSMOD_SCHEME:
+            os << "CKKSMOD";
+            break;
         case BFVRNS_SCHEME:
             os << "BFVRNS";
             break;
diff --git a/src/pke/lib/schemebase/base-cryptoparameters.cpp b/src/pke/lib/schemebase/base-cryptoparameters.cpp
index f8add26..74b2ada 100644
--- a/src/pke/lib/schemebase/base-cryptoparameters.cpp
+++ b/src/pke/lib/schemebase/base-cryptoparameters.cpp
@@ -37,5 +37,6 @@ namespace lbcrypto {
 // template class CryptoParametersBase<Poly>;
 // template class CryptoParametersBase<NativePoly>;
 template class CryptoParametersBase<DCRTPoly>;
+template class CryptoParametersBase<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/schemebase/base-leveledshe.cpp b/src/pke/lib/schemebase/base-leveledshe.cpp
index 29f0cf9..814276e 100644
--- a/src/pke/lib/schemebase/base-leveledshe.cpp
+++ b/src/pke/lib/schemebase/base-leveledshe.cpp
@@ -471,7 +471,7 @@ Ciphertext<Element> LeveledSHEBase<Element>::EvalAutomorphism(ConstCiphertext<El
 template <class Element>
 std::shared_ptr<std::vector<Element>> LeveledSHEBase<Element>::EvalFastRotationPrecompute(
     ConstCiphertext<Element> ciphertext) const {
-    const std::vector<DCRTPoly>& cv = ciphertext->GetElements();
+    const std::vector<Element>& cv = ciphertext->GetElements();
     auto algo                       = ciphertext->GetCryptoContext()->GetScheme();
 
     return algo->EvalKeySwitchPrecomputeCore(cv[1], ciphertext->GetCryptoParameters());
@@ -499,7 +499,7 @@ Ciphertext<Element> LeveledSHEBase<Element>::EvalFastRotation(
     auto evalKey = evalKeyIterator->second;
 
     auto algo                       = cc->GetScheme();
-    const std::vector<DCRTPoly>& cv = ciphertext->GetElements();
+    const std::vector<Element>& cv = ciphertext->GetElements();
 
     std::shared_ptr<std::vector<Element>> ba = algo->EvalFastKeySwitchCore(digits, evalKey, cv[0].GetParams());
 
@@ -835,5 +835,6 @@ namespace lbcrypto {
 // template class LeveledSHEBase<Poly>;
 // template class LeveledSHEBase<NativePoly>;
 template class LeveledSHEBase<DCRTPoly>;
+template class LeveledSHEBase<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/schemebase/base-parametergeneration.cpp b/src/pke/lib/schemebase/base-parametergeneration.cpp
index a217ccb..10bef7c 100644
--- a/src/pke/lib/schemebase/base-parametergeneration.cpp
+++ b/src/pke/lib/schemebase/base-parametergeneration.cpp
@@ -34,4 +34,5 @@
 // the code below is from base-parametergeneration-impl.cpp
 namespace lbcrypto {
 template class ParameterGenerationBase<DCRTPoly>;
+template class ParameterGenerationBase<DCRTModule>;
 }  // namespace lbcrypto
diff --git a/src/pke/lib/schemebase/base-pke.cpp b/src/pke/lib/schemebase/base-pke.cpp
index 87ff7d1..248aadd 100644
--- a/src/pke/lib/schemebase/base-pke.cpp
+++ b/src/pke/lib/schemebase/base-pke.cpp
@@ -209,5 +209,6 @@ Element PKEBase<Element>::DecryptCore(const std::vector<Element>& cv, const Priv
 namespace lbcrypto {
 
 template class PKEBase<DCRTPoly>;
+template class PKEBase<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/schemebase/base-scheme.cpp b/src/pke/lib/schemebase/base-scheme.cpp
index 15f3069..be53f7b 100644
--- a/src/pke/lib/schemebase/base-scheme.cpp
+++ b/src/pke/lib/schemebase/base-scheme.cpp
@@ -65,6 +65,23 @@ Ciphertext<Element> SchemeBase<Element>::ReEncrypt(ConstCiphertext<Element> ciph
     return result;
 }
 
+template <typename Element>
+EvalKey<Element> SchemeBase<Element>::EvalRankRedKeyGen(const PrivateKey<Element> privateKey, PrivateKey<Element>& reducedKey, usint newRank) const {
+    VerifyLeveledSHEEnabled(__func__);
+    if (!privateKey)
+        OPENFHE_THROW("Input private key is nullptr");
+
+    auto evalKey = m_LeveledSHE->EvalRankRedKeyGen(privateKey, reducedKey, newRank);
+    evalKey->SetKeyTag(privateKey->GetKeyTag());
+    return evalKey;
+}
+
+template <typename Element>
+Ciphertext<Element> SchemeBase<Element>::EvalRankReduce(ConstCiphertext<Element> ciphertext, EvalKey<Element> reduceKey) const {
+    VerifyLeveledSHEEnabled(__func__);
+    return m_LeveledSHE->EvalRankReduce(ciphertext, reduceKey);
+}
+
 template <typename Element>
 EvalKey<Element> SchemeBase<Element>::EvalMultKeyGen(const PrivateKey<Element> privateKey) const {
     VerifyLeveledSHEEnabled(__func__);
@@ -76,6 +93,18 @@ EvalKey<Element> SchemeBase<Element>::EvalMultKeyGen(const PrivateKey<Element> p
     return evalKey;
 }
 
+template <typename Element>
+std::vector<EvalKey<Element>> SchemeBase<Element>::EvalMultModKeyGen(const PrivateKey<Element> privateKey) const {
+    VerifyLeveledSHEEnabled(__func__);
+    if (!privateKey)
+        OPENFHE_THROW("Input private key is nullptr");
+
+    auto evalKeyVec = m_LeveledSHE->EvalMultModKeyGen(privateKey);
+    for (auto& evalKey : evalKeyVec)
+        evalKey->SetKeyTag(privateKey->GetKeyTag());
+    return evalKeyVec;
+}
+
 template <typename Element>
 std::vector<EvalKey<Element>> SchemeBase<Element>::EvalMultKeysGen(const PrivateKey<Element> privateKey) const {
     VerifyLeveledSHEEnabled(__func__);
@@ -445,5 +474,6 @@ std::shared_ptr<std::map<usint, EvalKey<Element>>> SchemeBase<Element>::EvalAuto
 }
 
 template class SchemeBase<DCRTPoly>;
+template class SchemeBase<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/schemebase/rlwe-cryptoparameters-impl.cpp b/src/pke/lib/schemebase/rlwe-cryptoparameters-impl.cpp
index a23a9e3..36dc5b2 100644
--- a/src/pke/lib/schemebase/rlwe-cryptoparameters-impl.cpp
+++ b/src/pke/lib/schemebase/rlwe-cryptoparameters-impl.cpp
@@ -37,5 +37,6 @@ namespace lbcrypto {
 // template class CryptoParametersRLWE<Poly>;
 // template class CryptoParametersRLWE<NativePoly>;
 template class CryptoParametersRLWE<DCRTPoly>;
+template class CryptoParametersRLWE<DCRTModule>;
 
 }  // namespace lbcrypto
diff --git a/src/pke/lib/schemerns/rns-cryptoparameters.cpp b/src/pke/lib/schemerns/rns-cryptoparameters.cpp
index 19bcf35..f21c95d 100644
--- a/src/pke/lib/schemerns/rns-cryptoparameters.cpp
+++ b/src/pke/lib/schemerns/rns-cryptoparameters.cpp
@@ -37,7 +37,8 @@
 
 namespace lbcrypto {
 
-void CryptoParametersRNS::PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech,
+template<typename Element>
+void CryptoParametersRNSImpl<Element>::PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech,
                                               EncryptionTechnique encTech, MultiplicationTechnique multTech,
                                               uint32_t numPartQ, uint32_t auxBits, uint32_t extraBits) {
     // Set the key switching technique.
@@ -55,15 +56,15 @@ void CryptoParametersRNS::PrecomputeCRTTables(KeySwitchTechnique ksTech, Scaling
     // Set number of extraBits for lower error
     m_extraBits = extraBits;
 
-    size_t sizeQ = GetElementParams()->GetParams().size();
-    size_t n     = GetElementParams()->GetRingDimension();
+    size_t sizeQ = this->GetElementParams()->GetParams().size();
+    size_t n     = this->GetElementParams()->GetRingDimension();
 
     // Construct moduliQ and rootsQ from crypto parameters
     std::vector<NativeInteger> moduliQ(sizeQ);
     std::vector<NativeInteger> rootsQ(sizeQ);
     for (size_t i = 0; i < sizeQ; i++) {
-        moduliQ[i] = GetElementParams()->GetParams()[i]->GetModulus();
-        rootsQ[i]  = GetElementParams()->GetParams()[i]->GetRootOfUnity();
+        moduliQ[i] = this->GetElementParams()->GetParams()[i]->GetModulus();
+        rootsQ[i]  = this->GetElementParams()->GetParams()[i]->GetRootOfUnity();
     }
 
     // Pre-compute CRT::FFT values for Q
@@ -109,7 +110,7 @@ void CryptoParametersRNS::PrecomputeCRTTables(KeySwitchTechnique ksTech, Scaling
             auto startTower = j * a;
             auto endTower   = ((j + 1) * a - 1 < sizeQ) ? (j + 1) * a - 1 : sizeQ - 1;
             std::vector<std::shared_ptr<ILNativeParams>> params =
-                GetElementParams()->GetParamPartition(startTower, endTower);
+                this->GetElementParams()->GetParamPartition(startTower, endTower);
             std::vector<NativeInteger> moduli(params.size());
             std::vector<NativeInteger> roots(params.size());
             for (uint32_t i = 0; i < params.size(); i++) {
@@ -209,7 +210,7 @@ void CryptoParametersRNS::PrecomputeCRTTables(KeySwitchTechnique ksTech, Scaling
             }
         }
 
-        BigInteger modulusQ = GetElementParams()->GetModulus();
+        BigInteger modulusQ = this->GetElementParams()->GetModulus();
         // Pre-compute values [Q/q_i]_{p_j}
         // Pre-compute values [(Q/q_i)^{-1}]_{q_i}
         m_QlHatInvModq.resize(sizeQ);
@@ -332,9 +333,9 @@ void CryptoParametersRNS::PrecomputeCRTTables(KeySwitchTechnique ksTech, Scaling
     /////////////////////////////////////
     // BFVrns and BGVrns : Multiparty Decryption : ExpandCRTBasis
     /////////////////////////////////////
-    if (GetMultipartyMode() == NOISE_FLOODING_MULTIPARTY) {
+    if (this->GetMultipartyMode() == NOISE_FLOODING_MULTIPARTY) {
         // Pre-compute values [*(Q/q_i/q_0)^{-1}]_{q_i}
-        BigInteger modulusQ = BigInteger(GetElementParams()->GetModulus()) / BigInteger(moduliQ[0]);
+        BigInteger modulusQ = BigInteger(this->GetElementParams()->GetModulus()) / BigInteger(moduliQ[0]);
         m_multipartyQHatInvModq.resize(sizeQ - 1);
         m_multipartyQHatInvModqPrecon.resize(sizeQ - 1);
         m_multipartyQHatModq0.resize(sizeQ - 1);
@@ -357,7 +358,7 @@ void CryptoParametersRNS::PrecomputeCRTTables(KeySwitchTechnique ksTech, Scaling
             }
         }
 
-        modulusQ = BigInteger(GetElementParams()->GetModulus()) / BigInteger(moduliQ[0]);
+        modulusQ = BigInteger(this->GetElementParams()->GetModulus()) / BigInteger(moduliQ[0]);
         m_multipartyAlphaQModq0.resize(sizeQ - 1);
         for (usint l = sizeQ - 1; l > 0; l--) {
             if (l < sizeQ - 1)
@@ -381,11 +382,13 @@ void CryptoParametersRNS::PrecomputeCRTTables(KeySwitchTechnique ksTech, Scaling
     }
 }
 
-uint64_t CryptoParametersRNS::FindAuxPrimeStep() const {
-    return GetElementParams()->GetRingDimension();
+template<typename Element>
+uint64_t CryptoParametersRNSImpl<Element>::FindAuxPrimeStep() const {
+    return this->GetElementParams()->GetRingDimension();
 }
 
-std::pair<double, uint32_t> CryptoParametersRNS::EstimateLogP(uint32_t numPartQ, double firstModulusSize,
+template<typename Element>
+std::pair<double, uint32_t> CryptoParametersRNSImpl<Element>::EstimateLogP(uint32_t numPartQ, double firstModulusSize,
                                                               double dcrtBits, double extraModulusSize,
                                                               uint32_t numPrimes, uint32_t auxBits, bool addOne) {
     // numPartQ can not be zero as there is a division by numPartQ
@@ -437,4 +440,7 @@ std::pair<double, uint32_t> CryptoParametersRNS::EstimateLogP(uint32_t numPartQ,
     return std::make_pair(sizeP * auxBits, sizeP);
 }
 
+template class CryptoParametersRNSImpl<DCRTPoly>;
+template class CryptoParametersRNSImpl<DCRTModule>;
+
 }  // namespace lbcrypto
diff --git a/src/pke/unittest/utckksmod/UnitTestCKKSmod.cpp b/src/pke/unittest/utckksmod/UnitTestCKKSmod.cpp
new file mode 100644
index 0000000..189c52d
--- /dev/null
+++ b/src/pke/unittest/utckksmod/UnitTestCKKSmod.cpp
@@ -0,0 +1,878 @@
+//==================================================================================
+// BSD 2-Clause License
+//
+// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors
+//
+// All rights reserved.
+//
+// Author TPOC: contact@openfhe.org
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice, this
+//    list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//==================================================================================
+
+/*
+  Unit tests for the CKKS scheme
+ */
+
+#include "UnitTestUtils.h"
+#include "UnitTestCCParams.h"
+#include "UnitTestCryptoContext.h"
+
+#include <iostream>
+#include <vector>
+#include "gtest/gtest.h"
+#include <iterator>
+
+using namespace lbcrypto;
+
+//===========================================================================================================
+enum TEST_CASE_TYPE {
+    ADD_PACKED = 0,
+    MULT_PACKED,
+    AUTO_LEVEL_REDUCE,
+    ADD_PACKED_PRECISION,
+    MULT_PACKED_PRECISION,
+    SMALL_SCALING_MOD_SIZE,
+};
+
+static std::ostream& operator<<(std::ostream& os, const TEST_CASE_TYPE& type) {
+    std::string typeName;
+    switch (type) {
+        case ADD_PACKED:
+            typeName = "ADD_PACKED";
+            break;
+        case MULT_PACKED:
+            typeName = "MULT_PACKED";
+            break;
+        case AUTO_LEVEL_REDUCE:
+            typeName = "AUTO_LEVEL_REDUCE";
+            break;
+        case ADD_PACKED_PRECISION:
+            typeName = "ADD_PACKED_PRECISION";
+            break;
+        case MULT_PACKED_PRECISION:
+            typeName = "MULT_PACKED_PRECISION";
+            break;
+        case SMALL_SCALING_MOD_SIZE:
+            typeName = "SMALL_SCALING_MOD_SIZE";
+            break;
+        default:
+            typeName = "UNKNOWN";
+            break;
+    }
+    return os << typeName;
+}
+//===========================================================================================================
+struct TEST_CASE_UTCKKSMod {
+    TEST_CASE_TYPE testCaseType;
+    // test case description - MUST BE UNIQUE
+    std::string description;
+
+    UnitTestCCParams params;
+
+    // additional test case data
+    // ........
+    uint32_t slots;
+    ScalingTechnique lowerPrecisionTechnique;
+    ScalingTechnique higherPrecisionTechnique;
+
+
+    std::string buildTestName() const {
+        std::stringstream ss;
+        ss << testCaseType << "_" << description;
+        return ss.str();
+    }
+    std::string toString() const {
+        std::stringstream ss;
+        ss << "testCaseType [" << testCaseType << "], " << params.toString();
+        return ss.str();
+    }
+};
+
+// this lambda provides a name to be printed for every test run by INSTANTIATE_TEST_SUITE_P.
+// the name MUST be constructed from digits, letters and '_' only
+static auto testName = [](const testing::TestParamInfo<TEST_CASE_UTCKKSMod>& test) {
+    return test.param.buildTestName();
+};
+
+static std::ostream& operator<<(std::ostream& os, const TEST_CASE_UTCKKSMod& test) {
+    return os << test.toString();
+}
+//===========================================================================================================
+/***
+ * BATCH: The length of the packed vectors to be used with CKKS.
+ */
+constexpr usint RING_DIM      = 512;
+constexpr usint RING_DIM_HALF = 256;
+constexpr usint DSIZE         = 10;
+constexpr usint BATCH         = 8;
+constexpr usint MODULE_RANK   = 4;
+#if NATIVEINT != 128 && !defined(__EMSCRIPTEN__)
+constexpr usint RING_DIM_PREC = 2048;  // for test cases with approximation error comparison only
+#endif
+// MIN_PRECISION_DIFF is the minimal difference expected between approximation error/precision for FLEXIBLEAUTO and FLEXIBLEAUTOEXT
+constexpr double MIN_PRECISION_DIFF = 1.5;
+// clang-format off
+static std::vector<TEST_CASE_UTCKKSMod> testCases = {
+    // TestType,  Descr, Scheme,         RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { ADD_PACKED, "03", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    { ADD_PACKED, "04", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+#if NATIVEINT != 128
+    { ADD_PACKED, "06", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    { ADD_PACKED, "08", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    // TestType,            Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots, LowPrec,      HighPrec
+    { ADD_PACKED_PRECISION, "01", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0,     FLEXIBLEAUTO, FLEXIBLEAUTOEXT},
+    // Special cases when mult depth = 0 and FLEXIBLEAUTO* modes are used; checks that the scaling factor set correctly
+#endif
+    // ==========================================
+    // TestType,  Descr, Scheme,         RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { ADD_PACKED, "23", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+    { ADD_PACKED, "24", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+#if NATIVEINT != 128
+    { ADD_PACKED, "26", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+    { ADD_PACKED, "28", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+    // TestType,            Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots, LowPrec,      HighPrec
+    { ADD_PACKED_PRECISION, "21", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32,    FLEXIBLEAUTO, FLEXIBLEAUTOEXT},
+#endif
+    // ==========================================
+    // TestType,  Descr, Scheme,         RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { ADD_PACKED, "33", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+    { ADD_PACKED, "34", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+#if NATIVEINT != 128
+    { ADD_PACKED, "36", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+    { ADD_PACKED, "38", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+    // TestType,            Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots,         LowPrec,      HighPrec
+    { ADD_PACKED_PRECISION, "31", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF, FLEXIBLEAUTO, FLEXIBLEAUTOEXT},
+#endif
+    // ==========================================
+    // TestType,  Descr, Scheme,          RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { MULT_PACKED, "03", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    { MULT_PACKED, "04", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+#if NATIVEINT != 128
+    { MULT_PACKED, "06", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    { MULT_PACKED, "08", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    // TestType,             Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots, LowPrec,      HighPrec
+    { MULT_PACKED_PRECISION, "01", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0,     FLEXIBLEAUTO, FLEXIBLEAUTOEXT},
+    { MULT_PACKED_PRECISION, "03", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0,     FIXEDAUTO,    FLEXIBLEAUTO},
+#endif
+    // ==========================================
+    // TestType,  Descr, Scheme,          RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { MULT_PACKED, "13", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    { MULT_PACKED, "14", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+#if NATIVEINT != 128
+    { MULT_PACKED, "16", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    { MULT_PACKED, "18", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0},
+    // TestType,             Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots, LowPrec,      HighPrec
+    { MULT_PACKED_PRECISION, "11", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0,     FLEXIBLEAUTO, FLEXIBLEAUTOEXT},
+    { MULT_PACKED_PRECISION, "13", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   0,     FIXEDAUTO,    FLEXIBLEAUTO},
+#endif
+    // ==========================================
+    // TestType,  Descr, Scheme,          RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { MULT_PACKED, "23", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   BATCH},
+    { MULT_PACKED, "24", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   BATCH},
+#if NATIVEINT != 128
+    { MULT_PACKED, "26", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   BATCH},
+    { MULT_PACKED, "28", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   BATCH},
+    // TestType,             Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots, LowPrec,      HighPrec
+    { MULT_PACKED_PRECISION, "21", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   BATCH, FLEXIBLEAUTO, FLEXIBLEAUTOEXT},
+    { MULT_PACKED_PRECISION, "23", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   BATCH, FIXEDAUTO,    FLEXIBLEAUTO},
+#endif
+    // ==========================================
+    // TestType,  Descr, Scheme,          RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { MULT_PACKED, "33", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+    { MULT_PACKED, "34", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+#if NATIVEINT != 128
+    { MULT_PACKED, "36", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+    { MULT_PACKED, "38", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32},
+    // TestType,             Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots, LowPrec,      HighPrec
+    { MULT_PACKED_PRECISION, "31", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32,    FLEXIBLEAUTO, FLEXIBLEAUTOEXT },
+    { MULT_PACKED_PRECISION, "33", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   32,    FIXEDAUTO,    FLEXIBLEAUTO },
+#endif
+    // ==========================================
+    // TestType,  Descr, Scheme,          RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots
+    { MULT_PACKED, "43", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+    { MULT_PACKED, "44", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+#if NATIVEINT != 128
+    { MULT_PACKED, "46", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+    { MULT_PACKED, "48", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF},
+    // TestType,             Descr, Scheme,         RDim,      MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech, LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode, multiparty, decryptnoise, execmode, noiseestimate, rank, Slots,         LowPrec,      HighPrec
+    { MULT_PACKED_PRECISION, "41", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF, FLEXIBLEAUTO, FLEXIBLEAUTOEXT },
+    { MULT_PACKED_PRECISION, "43", {CKKSMOD_SCHEME, RING_DIM_PREC, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, DFLT,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK},   RING_DIM_HALF, FIXEDAUTO,    FLEXIBLEAUTO },
+#endif
+    // ==========================================
+    // TestType,        Descr, Scheme,          RDim, MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,        LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode
+    { AUTO_LEVEL_REDUCE, "03", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDMANUAL,     DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK}, },
+    { AUTO_LEVEL_REDUCE, "04", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FIXEDAUTO,       DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK}, },
+#if NATIVEINT != 128
+    { AUTO_LEVEL_REDUCE, "06", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTO,    DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK}, },
+    { AUTO_LEVEL_REDUCE, "08", {CKKSMOD_SCHEME, RING_DIM, 7,     DFLT,     DSIZE, BATCH,   DFLT,       DFLT,          DFLT,     HEStd_NotSet, HYBRID, FLEXIBLEAUTOEXT, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK}, },
+#endif
+#if !defined(EMSCRIPTEN)
+    // TestType,              Descr, Scheme,        RDim,   MultDepth, SModSize, DSize, BatchSz, SecKeyDist, MaxRelinSkDeg, FModSize, SecLvl,       KSTech, ScalTech,    LDigits, PtMod, StdDev, EvalAddCt, KSCt, MultTech, EncTech, PREMode
+    { SMALL_SCALING_MOD_SIZE, "01", {CKKSMOD_SCHEME, 32768, 19,        22,       DFLT,  DFLT,    DFLT,       DFLT,          23,       DFLT,         DFLT,   FIXEDMANUAL, DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK}, },
+    { SMALL_SCALING_MOD_SIZE, "02", {CKKSMOD_SCHEME, 32768, 16,        50,       DFLT,  DFLT,    DFLT,       DFLT,          50,       HEStd_NotSet, DFLT,   DFLT,        DFLT,    DFLT,  DFLT,   DFLT,      DFLT, DFLT,     DFLT,    DFLT,    DFLT,       DFLT,         DFLT,     DFLT,          MODULE_RANK}, },
+#endif
+    // ==========================================
+};
+// clang-format on
+//===========================================================================================================
+/**
+ * Function to check minimal difference between 2 numeric values
+ *
+ * @param high    higher value
+ * @param low     lower value
+ * @param diff    minimal expected difference between high and low
+ */
+template <typename T>
+bool checkMinDiff(const T& high, const T& low, const uint32_t diff) {
+    if (high > low)
+        return ((high - low) >= diff);
+    return false;
+}
+
+/**
+ * Function to check minimal difference between elements of 2 vectors with numeric values
+ *
+ * @param high   vector with higher values
+ * @param low    vector with lower values
+ * @param diff   minimal expected difference between elements in high and low
+ */
+template <typename V>
+bool checkMinDiff(const std::vector<V>& high, const std::vector<V>& low, const uint32_t diff) {
+    if (high.size() != low.size())
+        return false;
+
+    return std::equal(high.begin(), high.end(), low.begin(),
+                      [&diff](const V& high, const V& low) { return checkMinDiff(high, low, diff); });
+}
+
+/**
+ * Function to check minimal difference between elements of 2 vectors with numeric values
+ *
+ * @param high   vector with higher values
+ * @param low    vector with lower values
+ * @param errMsg Debug message to display upon failure
+ * @param diff   minimal expected difference between elements in high and low
+ */
+template <typename V>
+void checkMinDiff(const std::vector<V>& high, const std::vector<V>& low, const uint32_t diff,
+                  const std::string& errMsg) {
+    // print vector values to error message
+    std::stringstream ss;
+    ss << ": HIGHER precision/LOWER error: [";
+    std::copy(high.begin(), high.end(), std::ostream_iterator<V>(ss, " "));
+    ss << "]; LOWER precisions/HIGHER error: [";
+    std::copy(low.begin(), low.end(), std::ostream_iterator<V>(ss, " "));
+    ss << "]";
+
+    std::string msg(errMsg);
+    msg += ss.str();
+    EXPECT_TRUE(checkMinDiff(high, low, diff)) << msg;
+}
+//===========================================================================================================
+class UTCKKSMod : public ::testing::TestWithParam<TEST_CASE_UTCKKSMod> {
+    using Element = DCRTModule;
+
+    // the size for all vectors remains const - 8 elements
+    const usint VECTOR_SIZE = 8;
+
+    // The precision after which we consider two values equal.
+    // This is necessary because CKKS works for approximate numbers.
+    const double eps = EPSILON;
+
+    const double epsHigh = 0.00001;
+
+    const double factor = 1 << 25;
+
+    const std::vector<std::complex<double>> vectorOfInts0_7{0, 1, 2, 3, 4, 5, 6, 7};
+    const std::vector<std::complex<double>> vectorOfInts0_7_Neg{0, -1, -2, -3, -4, -5, -6, -7};
+    const std::vector<std::complex<double>> vectorOfInts0_7_Add{0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5};
+    const std::vector<std::complex<double>> vectorOfInts0_7_AddLargeScalar{
+        0 + factor, 1 + factor, 2 + factor, 3 + factor, 4 + factor, 5 + factor, 6 + factor, 7 + factor};
+    const std::vector<std::complex<double>> vectorOfInts0_7_Sub{-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5};
+    const std::vector<std::complex<double>> vectorOfInts0_7neg{0, -1, -2, -3, -4, -5, -6, -7};
+    const std::vector<std::complex<double>> vectorOfInts7_0{7, 6, 5, 4, 3, 2, 1, 0};
+
+    const std::vector<std::complex<double>> vectorOfInts1_8{1, 2, 3, 4, 5, 6, 7, 8};
+    const std::vector<std::complex<double>> vectorOfInts1_8neg{-1, -2, -3, -4, -5, -6, -7, -8};
+    const std::vector<std::complex<double>> vectorOfInts8_1{8, 7, 6, 5, 4, 3, 2, 1};
+
+    const std::vector<std::complex<double>> vectorOfInts1s{1, 1, 1, 1, 1, 1, 1, 1};  // all 1's
+    const std::vector<std::complex<double>> vectorOfInts1sNeg{-1, -1, -1, -1, -1, -1, -1, -1};  // all 1's
+
+    // CalculateApproximationError() calculates the precision number (or approximation error).
+    // The higher the precision, the less the error.
+    template <typename T>
+    double CalculateApproximationError(const std::vector<std::complex<double>>& result,
+                                       const std::vector<std::complex<double>>& expectedResult) {
+        OPENFHE_THROW("CalculateApproximationError() is not implemented for this datatype");
+    }
+
+protected:
+    void SetUp() {}
+
+    void TearDown() {
+        CryptoContextFactory<DCRTModule>::ReleaseAllContexts();
+    }
+
+    template <typename T>
+    bool UnitTest_Add_Packed(const TEST_CASE_UTCKKSMod& testData, std::vector<T>& approximationErrors,
+                             const std::string& failmsg = std::string()) {
+        try {
+            CryptoContext<Element> cc(UnitTestGenerateModuleContext(testData.params));
+
+            Plaintext plaintext1 = cc->MakeCKKSPackedPlaintext(vectorOfInts0_7, 1, 0, nullptr, testData.slots);
+            Plaintext plaintext1AddScalar =
+                cc->MakeCKKSPackedPlaintext(vectorOfInts0_7_Add, 1, 0, nullptr, testData.slots);
+            Plaintext plaintext1AddLargeScalar =
+                cc->MakeCKKSPackedPlaintext(vectorOfInts0_7_AddLargeScalar, 1, 0, nullptr, testData.slots);
+            Plaintext plaintext1SubScalar =
+                cc->MakeCKKSPackedPlaintext(vectorOfInts0_7_Sub, 1, 0, nullptr, testData.slots);
+            Plaintext negatives1 = cc->MakeCKKSPackedPlaintext(vectorOfInts0_7neg, 1, 0, nullptr, testData.slots);
+            Plaintext plaintext2 = cc->MakeCKKSPackedPlaintext(vectorOfInts7_0, 1, 0, nullptr, testData.slots);
+
+            Plaintext plaintextAdd = cc->MakeCKKSPackedPlaintext(std::vector<std::complex<double>>(VECTOR_SIZE, 7), 1,
+                                                                 0, nullptr, testData.slots);  // vector of 7s
+            Plaintext plaintextSub = cc->MakeCKKSPackedPlaintext(
+                std::vector<std::complex<double>>{-7, -5, -3, -1, 1, 3, 5, 7}, 1, 0, nullptr, testData.slots);
+
+
+            // Generate encryption keys
+            KeyPair<Element> kp = cc->KeyGen();
+
+            // Encrypt plaintexts
+            Ciphertext<Element> ciphertext1         = cc->Encrypt(kp.publicKey, plaintext1);
+            Ciphertext<Element> ciphertext1_mutable = cc->Encrypt(kp.publicKey, plaintext1);
+            Ciphertext<Element> ciphertext2         = cc->Encrypt(kp.publicKey, plaintext2);
+
+
+            // Testing EvalAdd
+            Plaintext results;
+            Ciphertext<Element> cResult;
+
+
+            cResult = cc->EvalAdd(ciphertext1, ciphertext2);
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(plaintextAdd->GetLength());
+            checkEquality(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " EvalAdd fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+
+
+            cc->EvalAddInPlace(ciphertext1_mutable, ciphertext2);
+            cc->Decrypt(kp.secretKey, ciphertext1_mutable, &results);
+            results->SetLength(plaintextAdd->GetLength());
+            checkEquality(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " EvalAddInPlace fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+            
+
+            // Testing operator+
+            cResult = ciphertext1 + ciphertext2;
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(plaintextAdd->GetLength());
+            checkEquality(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " operator+ fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+            
+
+            // Testing operator+=
+            Ciphertext<Element> caddInplace(ciphertext1);
+            caddInplace += ciphertext2;
+            cc->Decrypt(kp.secretKey, caddInplace, &results);
+            results->SetLength(plaintextAdd->GetLength());
+            checkEquality(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " operator+= fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextAdd->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+            
+
+            cResult = cc->EvalSub(ciphertext1, ciphertext2);
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(plaintextSub->GetLength());
+            checkEquality(plaintextSub->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " EvalSub fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextSub->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+            
+
+            // Testing operator-
+            cResult = ciphertext1 - ciphertext2;
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(plaintextSub->GetLength());
+            checkEquality(plaintextSub->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " operator- fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextSub->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+            
+
+            // Testing operator-=
+            Ciphertext<Element> csubInplace(ciphertext1);
+            csubInplace -= ciphertext2;
+            cc->Decrypt(kp.secretKey, csubInplace, &results);
+            results->SetLength(plaintextSub->GetLength());
+            checkEquality(plaintextSub->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " operator-= fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextSub->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+            
+
+            // Testing EvalNegate
+            cResult = cc->EvalNegate(ciphertext1);
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(negatives1->GetLength());
+            checkEquality(negatives1->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " EvalNegate fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(negatives1->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+
+
+            return true;
+        }
+        catch (std::exception& e) {
+            std::cerr << "Exception thrown from " << __func__ << "(): " << e.what() << std::endl;
+            // make it fail
+            EXPECT_TRUE(0 == 1) << failmsg;
+        }
+        catch (...) {
+            UNIT_TEST_HANDLE_ALL_EXCEPTIONS;
+        }
+
+        return false;
+    }
+
+    void UnitTest_Add_Packed(const TEST_CASE_UTCKKSMod& testData, const std::string& failmsg = std::string()) {
+        std::vector<double> precisions;
+        UnitTest_Add_Packed(testData, precisions, failmsg);
+    }
+
+    void UnitTest_Add_Packed_Precision(const TEST_CASE_UTCKKSMod& testData,
+                                       const std::string& failmsg = std::string()) {
+        TEST_CASE_UTCKKSMod testDataLocal(testData);
+
+        std::vector<double> lowPrecisions;
+        CryptoContextFactory<DCRTModule>::ReleaseAllContexts();
+        testDataLocal.params.scalTech = testDataLocal.lowerPrecisionTechnique;
+        if (!UnitTest_Add_Packed(testDataLocal, lowPrecisions, failmsg))
+            return;
+
+        std::vector<double> highPrecisions;
+        CryptoContextFactory<DCRTModule>::ReleaseAllContexts();
+        testDataLocal.params.scalTech = testDataLocal.higherPrecisionTechnique;
+        if (!UnitTest_Add_Packed(testDataLocal, highPrecisions, failmsg))
+            return;
+
+        checkMinDiff(highPrecisions, lowPrecisions, MIN_PRECISION_DIFF,
+                     failmsg + " Approximation errors' comparison failed");
+    }
+
+    template <typename T>
+    bool UnitTest_Mult_Packed(const TEST_CASE_UTCKKSMod& testData, std::vector<T>& approximationErrors,
+                              const std::string& failmsg = std::string()) {
+        try {
+            CryptoContext<Element> cc(UnitTestGenerateModuleContext(testData.params));
+
+            Plaintext plaintext1    = cc->MakeCKKSPackedPlaintext(vectorOfInts0_7, 1, 0, nullptr, testData.slots);
+            Plaintext plaintext2    = cc->MakeCKKSPackedPlaintext(vectorOfInts7_0, 1, 0, nullptr, testData.slots);
+            Plaintext plaintextNeg  = cc->MakeCKKSPackedPlaintext(vectorOfInts0_7_Neg, 1, 0, nullptr, testData.slots);
+            Plaintext plaintextMult = cc->MakeCKKSPackedPlaintext(
+                std::vector<std::complex<double>>({0, 6, 10, 12, 12, 10, 6, 0}), 1, 0, nullptr, testData.slots);
+            Plaintext plaintextLarge = cc->MakeCKKSPackedPlaintext(
+                std::vector<std::complex<double>>({factor, factor, 0, 0, 0, 0, 0, 0}), 1, 0, nullptr, testData.slots);
+            Plaintext plaintextLargeMult = cc->MakeCKKSPackedPlaintext(
+                std::vector<std::complex<double>>({7 * factor, 6 * factor, 0, 0, 0, 0, 0, 0}), 1, 0, nullptr,
+                testData.slots);
+            Plaintext plaintext1s = cc->MakeCKKSPackedPlaintext(vectorOfInts1s, 1, 0, nullptr, testData.slots);
+            Plaintext plaintextNeg1s = cc->MakeCKKSPackedPlaintext(vectorOfInts1sNeg, 1, 0, nullptr, testData.slots);
+
+            // Generate encryption keys
+            KeyPair<Element> kp = cc->KeyGen();
+
+            // Generate multiplication keys
+            cc->EvalMultModKeyGen(kp.secretKey);
+
+
+            // Encrypt plaintexts
+            Ciphertext<Element> ciphertext1 = cc->Encrypt(kp.publicKey, plaintext1);
+            Ciphertext<Element> ciphertext2 = cc->Encrypt(kp.publicKey, plaintext2);
+            Ciphertext<Element> ciphertext1s = cc->Encrypt(kp.publicKey, plaintext1s);
+            Ciphertext<Element> ciphertextNeg1s = cc->Encrypt(kp.publicKey, plaintextNeg1s);
+
+            // adding an extra multiplication so that precision tests could clearly
+            // show differences between different scaling techniques
+            ciphertext1 = cc->EvalMultAndRelinearize(ciphertext1, ciphertext1s);
+            cc->RescaleInPlace(ciphertext1);
+            ciphertext2 = cc->EvalMultAndRelinearize(ciphertext2, ciphertext1s);
+            cc->RescaleInPlace(ciphertext2);
+
+            // Testing EvalMultAndRelinearize
+            Ciphertext<Element> cResult;
+            Plaintext results;
+            cResult = cc->EvalMultAndRelinearize(ciphertext1, ciphertext2);
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(plaintextMult->GetLength());
+            checkEquality(plaintextMult->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " EvalMultAndRelinearize fails");
+            approximationErrors.emplace_back(
+                CalculateApproximationError<T>(plaintextMult->GetCKKSPackedValue(), results->GetCKKSPackedValue()));
+
+            // Testing EvalMultAndRelinearize ciphertext * positive double
+            cResult = cc->EvalMultAndRelinearize(ciphertext1, ciphertext1s);
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(plaintext1->GetLength());
+            checkEquality(plaintext1->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " EvalMultAndRelinearize Ct and positive double fails");
+
+            // Testing EvalMultAndRelinearize ciphertext * negative double
+            cResult = cc->EvalMultAndRelinearize(ciphertext1, ciphertextNeg1s);
+            cc->Decrypt(kp.secretKey, cResult, &results);
+            results->SetLength(plaintextNeg->GetLength());
+            std::stringstream buffer1;
+            buffer1 << "should be: " << plaintextNeg->GetCKKSPackedValue()
+                    << " - we get: " << results->GetCKKSPackedValue();
+            checkEquality(plaintextNeg->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " EvalMultAndRelinearize Ct and negative double fails; " + buffer1.str());
+
+            return true;
+        }
+        catch (std::exception& e) {
+            std::cerr << "Exception thrown from " << __func__ << "(): " << e.what() << std::endl;
+            // make it fail
+            EXPECT_TRUE(0 == 1) << failmsg;
+        }
+        catch (...) {
+            UNIT_TEST_HANDLE_ALL_EXCEPTIONS;
+        }
+
+        return false;
+    }
+
+    void UnitTest_Mult_Packed(const TEST_CASE_UTCKKSMod& testData, const std::string& failmsg = std::string()) {
+        std::vector<double> precisions;
+        UnitTest_Mult_Packed(testData, precisions, failmsg);
+    }
+
+    void UnitTest_Mult_Packed_Precision(const TEST_CASE_UTCKKSMod& testData,
+                                        const std::string& failmsg = std::string()) {
+        TEST_CASE_UTCKKSMod testDataLocal(testData);
+
+        std::vector<double> lowPrecisions;
+        CryptoContextFactory<DCRTModule>::ReleaseAllContexts();
+        testDataLocal.params.scalTech = testDataLocal.lowerPrecisionTechnique;
+        if (!UnitTest_Mult_Packed(testDataLocal, lowPrecisions, failmsg))
+            return;
+
+        std::vector<double> highPrecisions;
+        CryptoContextFactory<DCRTModule>::ReleaseAllContexts();
+        testDataLocal.params.scalTech = testDataLocal.higherPrecisionTechnique;
+        if (!UnitTest_Mult_Packed(testDataLocal, highPrecisions, failmsg))
+            return;
+
+        checkMinDiff(highPrecisions, lowPrecisions, MIN_PRECISION_DIFF,
+                     failmsg + " Approximation errors' comparison failed");
+    }
+
+    void UnitTest_AutoLevelReduce(const TEST_CASE_UTCKKSMod& testData, const std::string& failmsg = std::string()) {
+        try {
+            CryptoContext<Element> cc(UnitTestGenerateModuleContext(testData.params));
+
+            std::vector<std::complex<double>> vectorOfInts1(vectorOfInts0_7);
+            Plaintext plaintext1 = cc->MakeCKKSPackedPlaintext(vectorOfInts1);
+
+            std::vector<std::complex<double>> vectorOfInts2(vectorOfInts7_0);
+            Plaintext plaintext2 = cc->MakeCKKSPackedPlaintext(vectorOfInts2);
+
+            std::vector<std::complex<double>> pCtMult(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCtMult3(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt3(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt3_b(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt4(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt5(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt6(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt7(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt_5(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt_6(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt_7(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt8(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt9(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt10(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt11(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt12(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt13(VECTOR_SIZE);
+            std::vector<std::complex<double>> pCt14(VECTOR_SIZE);
+            for (usint i = 0; i < VECTOR_SIZE; i++) {
+                pCtMult[i] = vectorOfInts1[i] * vectorOfInts2[i];
+                pCt3[i]    = pCtMult[i] + vectorOfInts1[i];
+                pCt4[i]    = pCtMult[i] - vectorOfInts1[i];
+                pCt5[i]    = pCtMult[i] * vectorOfInts1[i];
+                pCt6[i]    = vectorOfInts1[i] + pCtMult[i];
+                pCt7[i]    = vectorOfInts1[i] - pCtMult[i];
+                auto tmp =
+                    (vectorOfInts1[i] * vectorOfInts1[i] + vectorOfInts1[i] * vectorOfInts1[i]) * vectorOfInts1[i];
+                pCt_5[i]    = tmp + vectorOfInts2[i];
+                pCt_6[i]    = tmp - vectorOfInts2[i];
+                pCt_7[i]    = tmp * vectorOfInts2[i];
+                pCt8[i]     = vectorOfInts1[i] * pCtMult[i];
+                pCtMult3[i] = pCtMult[i] * vectorOfInts1[i] * vectorOfInts1[i];
+                pCt9[i]     = pCtMult3[i] + vectorOfInts1[i];
+                pCt10[i]    = pCtMult3[i] - vectorOfInts1[i];
+                pCt11[i]    = pCtMult3[i] * vectorOfInts1[i];
+                pCt12[i]    = vectorOfInts1[i] + pCtMult3[i];
+                pCt13[i]    = vectorOfInts1[i] - pCtMult3[i];
+                pCt14[i]    = vectorOfInts1[i] * pCtMult3[i];
+            }
+            Plaintext plaintextCt3  = cc->MakeCKKSPackedPlaintext(pCt3);
+            Plaintext plaintextCt4  = cc->MakeCKKSPackedPlaintext(pCt4);
+            Plaintext plaintextCt5  = cc->MakeCKKSPackedPlaintext(pCt5);
+            Plaintext plaintextCt6  = cc->MakeCKKSPackedPlaintext(pCt6);
+            Plaintext plaintextCt7  = cc->MakeCKKSPackedPlaintext(pCt7);
+            Plaintext plaintextCt_5 = cc->MakeCKKSPackedPlaintext(pCt_5);
+            Plaintext plaintextCt_6 = cc->MakeCKKSPackedPlaintext(pCt_6);
+            Plaintext plaintextCt_7 = cc->MakeCKKSPackedPlaintext(pCt_7);
+            Plaintext plaintextCt8  = cc->MakeCKKSPackedPlaintext(pCt8);
+            Plaintext plaintextCt9  = cc->MakeCKKSPackedPlaintext(pCt9);
+            Plaintext plaintextCt10 = cc->MakeCKKSPackedPlaintext(pCt10);
+            Plaintext plaintextCt11 = cc->MakeCKKSPackedPlaintext(pCt11);
+            Plaintext plaintextCt12 = cc->MakeCKKSPackedPlaintext(pCt12);
+            Plaintext plaintextCt13 = cc->MakeCKKSPackedPlaintext(pCt13);
+            Plaintext plaintextCt14 = cc->MakeCKKSPackedPlaintext(pCt14);
+
+            // Generate encryption keys
+            KeyPair<Element> kp = cc->KeyGen();
+            // Generate multiplication keys
+            cc->EvalMultModKeyGen(kp.secretKey);
+
+            // Encrypt plaintexts
+            Ciphertext<Element> ct  = cc->Encrypt(kp.publicKey, plaintext1);
+            Ciphertext<Element> ct2 = cc->Encrypt(kp.publicKey, plaintext2);
+
+            auto ctMul = cc->EvalMultAndRelinearize(ct, ct2);
+            auto ctRed = cc->ModReduce(ctMul);
+
+            Plaintext results;
+            // Addition with tower diff = 1
+            auto ct3 = cc->EvalAdd(ctRed, ct);
+            cc->Decrypt(kp.secretKey, ct3, &results);
+            results->SetLength(plaintextCt3->GetLength());
+            checkEquality(plaintextCt3->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " addition with tower diff = 1 fails");
+
+            // in-place addition with tower diff = 1
+            auto ctRedClone = ctRed->Clone();
+            cc->EvalAddInPlace(ctRedClone, ct);
+            cc->Decrypt(kp.secretKey, ctRedClone, &results);
+            results->SetLength(plaintextCt3->GetLength());
+            checkEquality(plaintextCt3->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " in-place addition with tower diff = 1 fails");
+
+            // Subtraction with tower diff = 1
+            auto ct4 = cc->EvalSub(ctRed, ct);
+            cc->Decrypt(kp.secretKey, ct4, &results);
+            results->SetLength(plaintextCt4->GetLength());
+            checkEquality(plaintextCt4->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " subtraction with tower diff = 1 fails");
+
+            // Multiplication with tower diff = 1
+            auto ct5 = cc->EvalMultAndRelinearize(ctRed, ct);
+            cc->Decrypt(kp.secretKey, ct5, &results);
+            results->SetLength(plaintextCt5->GetLength());
+            checkEquality(plaintextCt5->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " multiplication with tower diff = 1 fails");
+
+            // Addition with tower diff = 1 (inputs reversed)
+            auto ct6 = cc->EvalAdd(ct, ctRed);
+            cc->Decrypt(kp.secretKey, ct6, &results);
+            results->SetLength(plaintextCt6->GetLength());
+            checkEquality(plaintextCt6->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " addition (reverse) with tower diff = 1 fails");
+
+            // in-place addition with tower diff = 1 (inputs reversed)
+            Ciphertext<Element> ctClone = ct->Clone();
+            cc->EvalAddInPlace(ctClone, ctRed);
+            cc->Decrypt(kp.secretKey, ctClone, &results);
+            results->SetLength(plaintextCt6->GetLength());
+            checkEquality(plaintextCt6->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " in-place addition (reverse) with tower diff = 1 fails");
+
+            // Subtraction with tower diff = 1 (inputs reversed)
+            auto ct7 = cc->EvalSub(ct, ctRed);
+            cc->Decrypt(kp.secretKey, ct7, &results);
+            results->SetLength(plaintextCt7->GetLength());
+            checkEquality(plaintextCt7->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " subtraction (reverse) with tower diff = 1 fails");
+
+            // Multiplication with tower diff = 1 (inputs reversed)
+            auto ct8 = cc->EvalMultAndRelinearize(ct, ctRed);
+            cc->Decrypt(kp.secretKey, ct8, &results);
+            results->SetLength(plaintextCt8->GetLength());
+            checkEquality(plaintextCt8->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " multiplication (reverse) with tower diff = 1 fails");
+
+            auto ctMul2 = cc->EvalMultAndRelinearize(ctRed, ct);
+            auto ctRed2 = cc->ModReduce(ctMul2);
+            auto ctMul3 = cc->EvalMultAndRelinearize(ctRed2, ct);
+            auto ctRed3 = cc->ModReduce(ctMul3);
+
+            // Addition with more than 1 level difference
+            auto ct9 = cc->EvalAdd(ctRed3, ct);
+            cc->Decrypt(kp.secretKey, ct9, &results);
+            results->SetLength(plaintextCt9->GetLength());
+            checkEquality(plaintextCt9->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " addition with tower diff > 1 fails");
+
+            // In-place addition with more than 1 level difference
+            auto ctRed3Clone = ctRed3->Clone();
+            cc->EvalAddInPlace(ctRed3Clone, ct);
+            cc->Decrypt(kp.secretKey, ctRed3Clone, &results);
+            results->SetLength(plaintextCt9->GetLength());
+            checkEquality(plaintextCt9->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " in-place addition with tower diff > 1 fails");
+
+            // Subtraction with more than 1 level difference
+            auto ct10 = cc->EvalSub(ctRed3, ct);
+            cc->Decrypt(kp.secretKey, ct10, &results);
+            results->SetLength(plaintextCt10->GetLength());
+            checkEquality(plaintextCt10->GetCKKSPackedValue(), results->GetCKKSPackedValue(), epsHigh,
+                          failmsg + " in-place addition with tower diff > 1 fails");
+
+            // Multiplication with more than 1 level difference
+            auto ct11 = cc->EvalMultAndRelinearize(ctRed3, ct);
+            cc->Decrypt(kp.secretKey, ct11, &results);
+            results->SetLength(plaintextCt11->GetLength());
+            std::stringstream buffer;
+            buffer << plaintextCt11->GetCKKSPackedValue() << " - we get: " << results->GetCKKSPackedValue();
+            checkEquality(plaintextCt11->GetCKKSPackedValue(), results->GetCKKSPackedValue(), epsHigh,
+                          failmsg + " multiplication with tower diff > 1 fails" + buffer.str());
+
+            // Addition with more than 1 level difference (inputs reversed)
+            auto ct12 = cc->EvalAdd(ct, ctRed3);
+            cc->Decrypt(kp.secretKey, ct12, &results);
+            results->SetLength(plaintextCt12->GetLength());
+            checkEquality(plaintextCt12->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " addition (reverse) with tower diff > 1 fails");
+
+            // In-place addition with more than 1 level difference (inputs reversed)
+            ctClone = ct->Clone();
+            cc->EvalAddInPlace(ctClone, ctRed3);
+            cc->Decrypt(kp.secretKey, ctClone, &results);
+            results->SetLength(plaintextCt12->GetLength());
+            checkEquality(plaintextCt12->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " in-place addition (reverse) with tower diff > 1 fails");
+
+            // Subtraction with more than 1 level difference (inputs reversed)
+            auto ct13 = cc->EvalSub(ct, ctRed3);
+            cc->Decrypt(kp.secretKey, ct13, &results);
+            results->SetLength(plaintextCt13->GetLength());
+            checkEquality(plaintextCt13->GetCKKSPackedValue(), results->GetCKKSPackedValue(), eps,
+                          failmsg + " subtraction (reverse) with tower diff > 1 fails");
+
+            // Multiplication with more than 1 level difference (inputs reversed)
+            auto ct14 = cc->EvalMultAndRelinearize(ct, ctRed3);
+            cc->Decrypt(kp.secretKey, ct14, &results);
+            results->SetLength(plaintextCt14->GetLength());
+            checkEquality(plaintextCt14->GetCKKSPackedValue(), results->GetCKKSPackedValue(), epsHigh,
+                          failmsg + " multiplication (reverse) with tower diff > 1 fails");
+        }
+        catch (std::exception& e) {
+            std::cerr << "Exception thrown from " << __func__ << "(): " << e.what() << std::endl;
+            // make it fail
+            EXPECT_TRUE(0 == 1) << failmsg;
+        }
+        catch (...) {
+            UNIT_TEST_HANDLE_ALL_EXCEPTIONS;
+        }
+    }
+
+    void UnitTest_Small_ScalingModSize(const TEST_CASE_UTCKKSMod& testData,
+                                       const std::string& failmsg = std::string()) {
+        try {
+            CryptoContext<Element> cc(UnitTestGenerateModuleContext(testData.params));
+        }
+        catch (std::exception& e) {
+            std::cerr << "Exception thrown from " << __func__ << "(): " << e.what() << std::endl;
+            // make it fail
+            EXPECT_TRUE(0 == 1) << failmsg;
+        }
+        catch (...) {
+            UNIT_TEST_HANDLE_ALL_EXCEPTIONS;
+        }
+    }
+};
+
+template <>
+double UTCKKSMod::CalculateApproximationError<double>(const std::vector<std::complex<double>>& result,
+                                                      const std::vector<std::complex<double>>& expectedResult) {
+    if (result.size() != expectedResult.size())
+        OPENFHE_THROW("Cannot compare vectors with different numbers of elements");
+
+    // using the Euclidean norm
+    double avrg = 0;
+    for (size_t i = 0; i < result.size(); ++i) {
+        avrg += std::pow(std::abs(result[i].real() - expectedResult[i].real()), 2);
+    }
+
+    avrg = std::sqrt(avrg) / result.size();  // get the average
+    return std::abs(std::log2(avrg));
+}
+
+// template<>
+// uint32_t UTCKKSMod::CalculateApproximationError<int>(
+//    const std::vector<std::complex<double>>& result,
+//    const std::vector<std::complex<double>>& expectedResult) {
+//
+//    double err = CalculateApproximationError<double>(result, expectedResult);
+//    return std::round(err * 10) / 10; // should return an unsigned integer
+// }
+
+//===========================================================================================================
+TEST_P(UTCKKSMod, CKKSRNS) {
+    setupSignals();
+    auto test = GetParam();
+
+    switch (test.testCaseType) {
+        case ADD_PACKED:
+            UnitTest_Add_Packed(test, test.buildTestName());
+            break;
+        case MULT_PACKED:
+            UnitTest_Mult_Packed(test, test.buildTestName());
+            break;
+        case AUTO_LEVEL_REDUCE:
+            UnitTest_AutoLevelReduce(test, test.buildTestName());
+            break;
+        case ADD_PACKED_PRECISION:
+            UnitTest_Add_Packed_Precision(test, test.buildTestName());
+            break;
+        case MULT_PACKED_PRECISION:
+            UnitTest_Mult_Packed_Precision(test, test.buildTestName());
+            break;
+        case SMALL_SCALING_MOD_SIZE:
+            UnitTest_Small_ScalingModSize(test, test.buildTestName());
+            break;
+        default:
+            break;
+    }
+}
+
+INSTANTIATE_TEST_SUITE_P(UnitTests, UTCKKSMod, ::testing::ValuesIn(testCases), testName);
diff --git a/src/pke/unittest/utils/UnitTestCCParams.h b/src/pke/unittest/utils/UnitTestCCParams.h
index fc28f5a..49ef2b7 100644
--- a/src/pke/unittest/utils/UnitTestCCParams.h
+++ b/src/pke/unittest/utils/UnitTestCCParams.h
@@ -67,6 +67,7 @@ struct UnitTestCCParams {
     double decryptionNoiseMode     = DFLT;  // CKKSRNS
     double executionMode           = DFLT;  // CKKSRNS
     double noiseEstimate           = DFLT;  // CKKSRNS
+    double moduleRank              = DFLT;  // CKKSMOD
 
     std::string toString() const;
 };
diff --git a/src/pke/unittest/utils/UnitTestCryptoContext.cpp b/src/pke/unittest/utils/UnitTestCryptoContext.cpp
index cb7debb..de49d7f 100644
--- a/src/pke/unittest/utils/UnitTestCryptoContext.cpp
+++ b/src/pke/unittest/utils/UnitTestCryptoContext.cpp
@@ -31,6 +31,7 @@
 
 #include "UnitTestCryptoContext.h"
 #include "scheme/ckksrns/gen-cryptocontext-ckksrns.h"
+#include "scheme/ckksmod/gen-cryptocontext-ckksmod.h"
 #include "scheme/bfvrns/gen-cryptocontext-bfvrns.h"
 #include "scheme/bgvrns/gen-cryptocontext-bgvrns.h"
 #include "gen-cryptocontext.h"
@@ -81,7 +82,7 @@ static void setCryptoContextParametersFromUnitTestCCParams(const UnitTestCCParam
     if (!isDefaultValue(params.numLargeDigits)) {
         parameters.SetNumLargeDigits(static_cast<uint32_t>(std::round(params.numLargeDigits)));
     }
-    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false) {
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false && std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == false) {
         if (!isDefaultValue(params.plaintextModulus)) {
             parameters.SetPlaintextModulus(static_cast<PlaintextModulus>(std::round(params.plaintextModulus)));
         }
@@ -100,12 +101,12 @@ static void setCryptoContextParametersFromUnitTestCCParams(const UnitTestCCParam
             parameters.SetEncryptionTechnique(static_cast<EncryptionTechnique>(std::round(params.encryptionTechnique)));
         }
     }
-    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false) {
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false && std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == false) {
         if (!isDefaultValue(params.evalAddCount)) {
             parameters.SetEvalAddCount(static_cast<usint>(std::round(params.evalAddCount)));
         }
     }
-    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false) {
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false && std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == false) {
         if (!isDefaultValue(params.keySwitchCount)) {
             parameters.SetKeySwitchCount(static_cast<usint>(std::round(params.keySwitchCount)));
         }
@@ -113,26 +114,31 @@ static void setCryptoContextParametersFromUnitTestCCParams(const UnitTestCCParam
     if (!isDefaultValue(params.PREMode)) {
         parameters.SetPREMode(static_cast<ProxyReEncryptionMode>(std::round(params.PREMode)));
     }
-    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false) {
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == false && std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == false) {
         if (!isDefaultValue(params.multipartyMode)) {
             parameters.SetMultipartyMode(static_cast<MultipartyMode>(std::round(params.multipartyMode)));
         }
     }
-    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == true) {
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == true || std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == true) {
         if (!isDefaultValue(params.decryptionNoiseMode)) {
             parameters.SetDecryptionNoiseMode(static_cast<DecryptionNoiseMode>(std::round(params.decryptionNoiseMode)));
         }
     }
-    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == true) {
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == true || std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == true) {
         if (!isDefaultValue(params.executionMode)) {
             parameters.SetExecutionMode(static_cast<ExecutionMode>(std::round(params.executionMode)));
         }
     }
-    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == true) {
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSRNS>> == true || std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == true) {
         if (!isDefaultValue(params.noiseEstimate)) {
             parameters.SetNoiseEstimate(params.noiseEstimate);
         }
     }
+    if constexpr (std::is_same_v<U, CCParams<CryptoContextCKKSMod>> == true) {
+        if (!isDefaultValue(params.moduleRank)) {
+            parameters.SetModuleRank(params.moduleRank);
+        }
+    }
 }
 //===========================================================================================================
 CryptoContext<Element> UnitTestGenerateContext(const UnitTestCCParams& params) {
@@ -170,6 +176,25 @@ CryptoContext<Element> UnitTestGenerateContext(const UnitTestCCParams& params) {
     return cc;
 }
 
+CryptoContext<lbcrypto::DCRTModule> UnitTestGenerateModuleContext(const UnitTestCCParams& params) {
+    CryptoContext<lbcrypto::DCRTModule> cc(nullptr);
+    if (CKKSMOD_SCHEME == params.schemeId) {
+        CCParams<CryptoContextCKKSMod> parameters;
+        setCryptoContextParametersFromUnitTestCCParams(params, parameters);
+
+        cc = GenCryptoContext(parameters);
+    }
+
+    if (!cc)
+        OPENFHE_THROW("Error generating crypto context.");
+
+    cc->Enable(PKE);
+    cc->Enable(KEYSWITCH);
+    cc->Enable(LEVELEDSHE);
+
+    return cc;
+}
+
 //===========================================================================================================
 CryptoContext<Element> UnitTestGenerateContext(const BaseTestCase& testCase) {
     CryptoContext<Element> cc(nullptr);
diff --git a/src/pke/unittest/utils/UnitTestCryptoContext.h b/src/pke/unittest/utils/UnitTestCryptoContext.h
index e1f61cb..3e60f12 100644
--- a/src/pke/unittest/utils/UnitTestCryptoContext.h
+++ b/src/pke/unittest/utils/UnitTestCryptoContext.h
@@ -42,4 +42,6 @@ using Element = lbcrypto::DCRTPoly;
 lbcrypto::CryptoContext<Element> UnitTestGenerateContext(const UnitTestCCParams& testData);
 lbcrypto::CryptoContext<Element> UnitTestGenerateContext(const BaseTestCase& testCase);
 
+lbcrypto::CryptoContext<lbcrypto::DCRTModule> UnitTestGenerateModuleContext(const UnitTestCCParams& params);
+
 #endif  // __UNITTESTCRYPTOCONTEXT_H__
